// This file is auto-generated by @hey-api/openapi-ts

/**
 * APIError is an api error with a message
 */
export type ApiError = {
    message?: string;
    url?: string;
};

export type AccessToken = {
    id?: number;
    name?: string;
    scopes?: Array<string>;
    sha1?: string;
    token_last_eight?: string;
};

/**
 * ActionArtifact represents a ActionArtifact
 */
export type ActionArtifact = {
    archive_download_url?: string;
    created_at?: string;
    expired?: boolean;
    expires_at?: string;
    id?: number;
    name?: string;
    size_in_bytes?: number;
    updated_at?: string;
    url?: string;
    workflow_run?: ActionWorkflowRun;
};

/**
 * ActionArtifactsResponse returns ActionArtifacts
 */
export type ActionArtifactsResponse = {
    artifacts?: Array<ActionArtifact>;
    total_count?: number;
};

/**
 * ActionTask represents a ActionTask
 */
export type ActionTask = {
    created_at?: string;
    display_title?: string;
    event?: string;
    head_branch?: string;
    head_sha?: string;
    id?: number;
    name?: string;
    run_number?: number;
    run_started_at?: string;
    status?: string;
    updated_at?: string;
    url?: string;
    workflow_id?: string;
};

/**
 * ActionTaskResponse returns a ActionTask
 */
export type ActionTaskResponse = {
    total_count?: number;
    workflow_runs?: Array<ActionTask>;
};

/**
 * ActionVariable return value of the query API
 */
export type ActionVariable = {
    /**
     * the value of the variable
     */
    data?: string;
    /**
     * the name of the variable
     */
    name?: string;
    /**
     * the owner to which the variable belongs
     */
    owner_id?: number;
    /**
     * the repository to which the variable belongs
     */
    repo_id?: number;
};

/**
 * ActionWorkflow represents a ActionWorkflow
 */
export type ActionWorkflow = {
    badge_url?: string;
    created_at?: string;
    deleted_at?: string;
    html_url?: string;
    id?: string;
    name?: string;
    path?: string;
    state?: string;
    updated_at?: string;
    url?: string;
};

/**
 * ActionWorkflowRun represents a WorkflowRun
 */
export type ActionWorkflowRun = {
    head_sha?: string;
    id?: number;
    repository_id?: number;
};

export type Activity = {
    act_user?: User;
    act_user_id?: number;
    comment?: Comment;
    comment_id?: number;
    content?: string;
    created?: string;
    id?: number;
    is_private?: boolean;
    /**
     * the type of action
     */
    op_type?: 'create_repo' | 'rename_repo' | 'star_repo' | 'watch_repo' | 'commit_repo' | 'create_issue' | 'create_pull_request' | 'transfer_repo' | 'push_tag' | 'comment_issue' | 'merge_pull_request' | 'close_issue' | 'reopen_issue' | 'close_pull_request' | 'reopen_pull_request' | 'delete_tag' | 'delete_branch' | 'mirror_sync_push' | 'mirror_sync_create' | 'mirror_sync_delete' | 'approve_pull_request' | 'reject_pull_request' | 'comment_pull' | 'publish_release' | 'pull_review_dismissed' | 'pull_request_ready_for_review' | 'auto_merge_pull_request';
    ref_name?: string;
    repo?: Repository;
    repo_id?: number;
    user_id?: number;
};

/**
 * ActivityPub type
 */
export type ActivityPub = {
    '@context'?: string;
};

/**
 * AddCollaboratorOption options when adding a user as a collaborator of a repository
 */
export type AddCollaboratorOption = {
    permission?: 'read' | 'write' | 'admin';
};

/**
 * AddTimeOption options for adding time to an issue
 */
export type AddTimeOption = {
    created?: string;
    /**
     * time in seconds
     */
    time: number;
    /**
     * User who spent the time (optional)
     */
    user_name?: string;
};

/**
 * AnnotatedTag represents an annotated tag
 */
export type AnnotatedTag = {
    message?: string;
    object?: AnnotatedTagObject;
    sha?: string;
    tag?: string;
    tagger?: CommitUser;
    url?: string;
    verification?: PayloadCommitVerification;
};

/**
 * AnnotatedTagObject contains meta information of the tag object
 */
export type AnnotatedTagObject = {
    sha?: string;
    type?: string;
    url?: string;
};

/**
 * Attachment a generic attachment
 */
export type Attachment = {
    browser_download_url?: string;
    created_at?: string;
    download_count?: number;
    id?: number;
    name?: string;
    size?: number;
    uuid?: string;
};

/**
 * Badge represents a user badge
 */
export type Badge = {
    description?: string;
    id?: number;
    image_url?: string;
    slug?: string;
};

/**
 * Branch represents a repository branch
 */
export type Branch = {
    commit?: PayloadCommit;
    effective_branch_protection_name?: string;
    enable_status_check?: boolean;
    name?: string;
    protected?: boolean;
    required_approvals?: number;
    status_check_contexts?: Array<string>;
    user_can_merge?: boolean;
    user_can_push?: boolean;
};

/**
 * BranchProtection represents a branch protection for a repository
 */
export type BranchProtection = {
    approvals_whitelist_teams?: Array<string>;
    approvals_whitelist_username?: Array<string>;
    block_admin_merge_override?: boolean;
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    /**
     * Deprecated: true
     */
    branch_name?: string;
    created_at?: string;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_force_push?: boolean;
    enable_force_push_allowlist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    force_push_allowlist_deploy_keys?: boolean;
    force_push_allowlist_teams?: Array<string>;
    force_push_allowlist_usernames?: Array<string>;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: Array<string>;
    merge_whitelist_usernames?: Array<string>;
    priority?: number;
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: Array<string>;
    push_whitelist_usernames?: Array<string>;
    require_signed_commits?: boolean;
    required_approvals?: number;
    rule_name?: string;
    status_check_contexts?: Array<string>;
    unprotected_file_patterns?: string;
    updated_at?: string;
};

/**
 * ChangeFileOperation for creating, updating or deleting a file
 */
export type ChangeFileOperation = {
    /**
     * new or updated file content, must be base64 encoded
     */
    content?: string;
    /**
     * old path of the file to move
     */
    from_path?: string;
    /**
     * indicates what to do with the file
     */
    operation: 'create' | 'update' | 'delete';
    /**
     * path to the existing or new file
     */
    path: string;
    /**
     * sha is the SHA for the file that already exists, required for update or delete
     */
    sha?: string;
};

/**
 * ChangeFilesOptions options for creating, updating or deleting multiple files
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type ChangeFilesOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    dates?: CommitDateOptions;
    /**
     * list of file operations
     */
    files: Array<ChangeFileOperation>;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * ChangedFile store information about files affected by the pull request
 */
export type ChangedFile = {
    additions?: number;
    changes?: number;
    contents_url?: string;
    deletions?: number;
    filename?: string;
    html_url?: string;
    previous_filename?: string;
    raw_url?: string;
    status?: string;
};

/**
 * CombinedStatus holds the combined state of several statuses for a single commit
 */
export type CombinedStatus = {
    commit_url?: string;
    repository?: Repository;
    sha?: string;
    state?: CommitStatusState;
    statuses?: Array<CommitStatus>;
    total_count?: number;
    url?: string;
};

/**
 * Comment represents a comment on a commit or issue
 */
export type Comment = {
    assets?: Array<Attachment>;
    body?: string;
    created_at?: string;
    html_url?: string;
    id?: number;
    issue_url?: string;
    original_author?: string;
    original_author_id?: number;
    pull_request_url?: string;
    updated_at?: string;
    user?: User;
};

export type Commit = {
    author?: User;
    commit?: RepoCommit;
    committer?: User;
    created?: string;
    files?: Array<CommitAffectedFiles>;
    html_url?: string;
    parents?: Array<CommitMeta>;
    sha?: string;
    stats?: CommitStats;
    url?: string;
};

/**
 * CommitAffectedFiles store information about files affected by the commit
 */
export type CommitAffectedFiles = {
    filename?: string;
    status?: string;
};

/**
 * CommitDateOptions store dates for GIT_AUTHOR_DATE and GIT_COMMITTER_DATE
 */
export type CommitDateOptions = {
    author?: string;
    committer?: string;
};

export type CommitMeta = {
    created?: string;
    sha?: string;
    url?: string;
};

/**
 * CommitStats is statistics for a RepoCommit
 */
export type CommitStats = {
    additions?: number;
    deletions?: number;
    total?: number;
};

/**
 * CommitStatus holds a single status of a single Commit
 */
export type CommitStatus = {
    context?: string;
    created_at?: string;
    creator?: User;
    description?: string;
    id?: number;
    status?: CommitStatusState;
    target_url?: string;
    updated_at?: string;
    url?: string;
};

/**
 * CommitStatusState holds the state of a CommitStatus
 * It can be "pending", "success", "error" and "failure"
 */
export type CommitStatusState = string;

export type CommitUser = {
    date?: string;
    email?: string;
    name?: string;
};

export type Compare = {
    commits?: Array<Commit>;
    total_commits?: number;
};

/**
 * ContentsResponse contains information about a repo's entry's (dir, file, symlink, submodule) metadata and content
 */
export type ContentsResponse = {
    _links?: FileLinksResponse;
    /**
     * `content` is populated when `type` is `file`, otherwise null
     */
    content?: string;
    download_url?: string;
    /**
     * `encoding` is populated when `type` is `file`, otherwise null
     */
    encoding?: string;
    git_url?: string;
    html_url?: string;
    last_commit_sha?: string;
    name?: string;
    path?: string;
    sha?: string;
    size?: number;
    /**
     * `submodule_git_url` is populated when `type` is `submodule`, otherwise null
     */
    submodule_git_url?: string;
    /**
     * `target` is populated when `type` is `symlink`, otherwise null
     */
    target?: string;
    /**
     * `type` will be `file`, `dir`, `symlink`, or `submodule`
     */
    type?: string;
    url?: string;
};

/**
 * CreateAccessTokenOption options when create access token
 */
export type CreateAccessTokenOption = {
    name: string;
    scopes?: Array<string>;
};

/**
 * CreateActionWorkflowDispatch represents the payload for triggering a workflow dispatch event
 */
export type CreateActionWorkflowDispatch = {
    inputs?: {
        [key: string]: string;
    };
    ref: string;
};

/**
 * CreateBranchProtectionOption options for creating a branch protection
 */
export type CreateBranchProtectionOption = {
    approvals_whitelist_teams?: Array<string>;
    approvals_whitelist_username?: Array<string>;
    block_admin_merge_override?: boolean;
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    /**
     * Deprecated: true
     */
    branch_name?: string;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_force_push?: boolean;
    enable_force_push_allowlist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    force_push_allowlist_deploy_keys?: boolean;
    force_push_allowlist_teams?: Array<string>;
    force_push_allowlist_usernames?: Array<string>;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: Array<string>;
    merge_whitelist_usernames?: Array<string>;
    priority?: number;
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: Array<string>;
    push_whitelist_usernames?: Array<string>;
    require_signed_commits?: boolean;
    required_approvals?: number;
    rule_name?: string;
    status_check_contexts?: Array<string>;
    unprotected_file_patterns?: string;
};

/**
 * CreateBranchRepoOption options when creating a branch in a repository
 */
export type CreateBranchRepoOption = {
    /**
     * Name of the branch to create
     */
    new_branch_name: string;
    /**
     * Deprecated: true
     * Name of the old branch to create from
     */
    old_branch_name?: string;
    /**
     * Name of the old branch/tag/commit to create from
     */
    old_ref_name?: string;
};

/**
 * CreateEmailOption options when creating email addresses
 */
export type CreateEmailOption = {
    /**
     * email addresses to add
     */
    emails?: Array<string>;
};

/**
 * CreateFileOptions options for creating files
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type CreateFileOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    /**
     * content must be base64 encoded
     */
    content: string;
    dates?: CommitDateOptions;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * CreateForkOption options for creating a fork
 */
export type CreateForkOption = {
    /**
     * name of the forked repository
     */
    name?: string;
    /**
     * organization name, if forking into an organization
     */
    organization?: string;
};

/**
 * CreateGPGKeyOption options create user GPG key
 */
export type CreateGpgKeyOption = {
    /**
     * An armored GPG key to add
     */
    armored_public_key: string;
    armored_signature?: string;
};

/**
 * CreateHookOption options when create a hook
 */
export type CreateHookOption = {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config: CreateHookOptionConfig;
    events?: Array<string>;
    type: 'dingtalk' | 'discord' | 'gitea' | 'gogs' | 'msteams' | 'slack' | 'telegram' | 'feishu' | 'wechatwork' | 'packagist';
};

/**
 * CreateHookOptionConfig has all config options in it
 * required are "content_type" and "url" Required
 */
export type CreateHookOptionConfig = {
    [key: string]: string;
};

/**
 * CreateIssueCommentOption options for creating a comment on an issue
 */
export type CreateIssueCommentOption = {
    body: string;
};

/**
 * CreateIssueOption options to create one issue
 */
export type CreateIssueOption = {
    /**
     * deprecated
     */
    assignee?: string;
    assignees?: Array<string>;
    body?: string;
    closed?: boolean;
    due_date?: string;
    /**
     * list of label ids
     */
    labels?: Array<number>;
    /**
     * milestone id
     */
    milestone?: number;
    ref?: string;
    title: string;
};

/**
 * CreateKeyOption options when creating a key
 */
export type CreateKeyOption = {
    /**
     * An armored SSH key to add
     */
    key: string;
    /**
     * Describe if the key has only read access or read/write
     */
    read_only?: boolean;
    /**
     * Title of the key to add
     */
    title: string;
};

/**
 * CreateLabelOption options for creating a label
 */
export type CreateLabelOption = {
    color: string;
    description?: string;
    exclusive?: boolean;
    is_archived?: boolean;
    name: string;
};

/**
 * CreateMilestoneOption options for creating a milestone
 */
export type CreateMilestoneOption = {
    description?: string;
    due_on?: string;
    state?: 'open' | 'closed';
    title?: string;
};

/**
 * CreateOAuth2ApplicationOptions holds options to create an oauth2 application
 */
export type CreateOAuth2ApplicationOptions = {
    confidential_client?: boolean;
    name?: string;
    redirect_uris?: Array<string>;
    skip_secondary_authorization?: boolean;
};

/**
 * CreateOrUpdateSecretOption options when creating or updating secret
 */
export type CreateOrUpdateSecretOption = {
    /**
     * Data of the secret to update
     */
    data: string;
};

/**
 * CreateOrgOption options for creating an organization
 */
export type CreateOrgOption = {
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    repo_admin_change_team_access?: boolean;
    username: string;
    /**
     * possible values are `public` (default), `limited` or `private`
     */
    visibility?: 'public' | 'limited' | 'private';
    website?: string;
};

/**
 * CreatePullRequestOption options when creating a pull request
 */
export type CreatePullRequestOption = {
    assignee?: string;
    assignees?: Array<string>;
    base?: string;
    body?: string;
    due_date?: string;
    head?: string;
    labels?: Array<number>;
    milestone?: number;
    reviewers?: Array<string>;
    team_reviewers?: Array<string>;
    title?: string;
};

/**
 * CreatePullReviewComment represent a review comment for creation api
 */
export type CreatePullReviewComment = {
    body?: string;
    /**
     * if comment to new file line or 0
     */
    new_position?: number;
    /**
     * if comment to old file line or 0
     */
    old_position?: number;
    /**
     * the tree path
     */
    path?: string;
};

/**
 * CreatePullReviewOptions are options to create a pull review
 */
export type CreatePullReviewOptions = {
    body?: string;
    comments?: Array<CreatePullReviewComment>;
    commit_id?: string;
    event?: ReviewStateType;
};

export type CreatePushMirrorOption = {
    interval?: string;
    remote_address?: string;
    remote_password?: string;
    remote_username?: string;
    sync_on_commit?: boolean;
};

/**
 * CreateReleaseOption options when creating a release
 */
export type CreateReleaseOption = {
    body?: string;
    draft?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name: string;
    target_commitish?: string;
};

/**
 * CreateRepoOption options when creating repository
 */
export type CreateRepoOption = {
    /**
     * Whether the repository should be auto-initialized?
     */
    auto_init?: boolean;
    /**
     * DefaultBranch of the repository (used when initializes and in template)
     */
    default_branch?: string;
    /**
     * Description of the repository to create
     */
    description?: string;
    /**
     * Gitignores to use
     */
    gitignores?: string;
    /**
     * Label-Set to use
     */
    issue_labels?: string;
    /**
     * License to use
     */
    license?: string;
    /**
     * Name of the repository to create
     */
    name: string;
    /**
     * ObjectFormatName of the underlying git repository
     */
    object_format_name?: 'sha1' | 'sha256';
    /**
     * Whether the repository is private
     */
    private?: boolean;
    /**
     * Readme of the repository to create
     */
    readme?: string;
    /**
     * Whether the repository is template
     */
    template?: boolean;
    /**
     * TrustModel of the repository
     */
    trust_model?: 'default' | 'collaborator' | 'committer' | 'collaboratorcommitter';
};

/**
 * CreateStatusOption holds the information needed to create a new CommitStatus for a Commit
 */
export type CreateStatusOption = {
    context?: string;
    description?: string;
    state?: CommitStatusState;
    target_url?: string;
};

/**
 * CreateTagOption options when creating a tag
 */
export type CreateTagOption = {
    message?: string;
    tag_name: string;
    target?: string;
};

/**
 * CreateTagProtectionOption options for creating a tag protection
 */
export type CreateTagProtectionOption = {
    name_pattern?: string;
    whitelist_teams?: Array<string>;
    whitelist_usernames?: Array<string>;
};

/**
 * CreateTeamOption options for creating a team
 */
export type CreateTeamOption = {
    can_create_org_repo?: boolean;
    description?: string;
    includes_all_repositories?: boolean;
    name: string;
    permission?: 'read' | 'write' | 'admin';
    units?: Array<string>;
    units_map?: {
        [key: string]: string;
    };
};

/**
 * CreateUserOption create user options
 */
export type CreateUserOption = {
    /**
     * For explicitly setting the user creation timestamp. Useful when users are
     * migrated from other systems. When omitted, the user's creation timestamp
     * will be set to "now".
     */
    created_at?: string;
    email: string;
    full_name?: string;
    login_name?: string;
    must_change_password?: boolean;
    password?: string;
    restricted?: boolean;
    send_notify?: boolean;
    source_id?: number;
    username: string;
    visibility?: string;
};

/**
 * CreateVariableOption the option when creating variable
 */
export type CreateVariableOption = {
    /**
     * Value of the variable to create
     */
    value: string;
};

/**
 * CreateWikiPageOptions form for creating wiki
 */
export type CreateWikiPageOptions = {
    /**
     * content must be base64 encoded
     */
    content_base64?: string;
    /**
     * optional commit message summarizing the change
     */
    message?: string;
    /**
     * page title. leave empty to keep unchanged
     */
    title?: string;
};

/**
 * Cron represents a Cron task
 */
export type Cron = {
    exec_times?: number;
    name?: string;
    next?: string;
    prev?: string;
    schedule?: string;
};

/**
 * DeleteEmailOption options when deleting email addresses
 */
export type DeleteEmailOption = {
    /**
     * email addresses to delete
     */
    emails?: Array<string>;
};

/**
 * DeleteFileOptions options for deleting files (used for other File structs below)
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type DeleteFileOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    dates?: CommitDateOptions;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * sha is the SHA for the file that already exists
     */
    sha: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * DeployKey a deploy key
 */
export type DeployKey = {
    created_at?: string;
    fingerprint?: string;
    id?: number;
    key?: string;
    key_id?: number;
    read_only?: boolean;
    repository?: Repository;
    title?: string;
    url?: string;
};

/**
 * DismissPullReviewOptions are options to dismiss a pull review
 */
export type DismissPullReviewOptions = {
    message?: string;
    priors?: boolean;
};

/**
 * EditAttachmentOptions options for editing attachments
 */
export type EditAttachmentOptions = {
    name?: string;
};

/**
 * EditBranchProtectionOption options for editing a branch protection
 */
export type EditBranchProtectionOption = {
    approvals_whitelist_teams?: Array<string>;
    approvals_whitelist_username?: Array<string>;
    block_admin_merge_override?: boolean;
    block_on_official_review_requests?: boolean;
    block_on_outdated_branch?: boolean;
    block_on_rejected_reviews?: boolean;
    dismiss_stale_approvals?: boolean;
    enable_approvals_whitelist?: boolean;
    enable_force_push?: boolean;
    enable_force_push_allowlist?: boolean;
    enable_merge_whitelist?: boolean;
    enable_push?: boolean;
    enable_push_whitelist?: boolean;
    enable_status_check?: boolean;
    force_push_allowlist_deploy_keys?: boolean;
    force_push_allowlist_teams?: Array<string>;
    force_push_allowlist_usernames?: Array<string>;
    ignore_stale_approvals?: boolean;
    merge_whitelist_teams?: Array<string>;
    merge_whitelist_usernames?: Array<string>;
    priority?: number;
    protected_file_patterns?: string;
    push_whitelist_deploy_keys?: boolean;
    push_whitelist_teams?: Array<string>;
    push_whitelist_usernames?: Array<string>;
    require_signed_commits?: boolean;
    required_approvals?: number;
    status_check_contexts?: Array<string>;
    unprotected_file_patterns?: string;
};

/**
 * EditDeadlineOption options for creating a deadline
 */
export type EditDeadlineOption = {
    due_date: string;
};

/**
 * EditGitHookOption options when modifying one Git hook
 */
export type EditGitHookOption = {
    content?: string;
};

/**
 * EditHookOption options when modify one hook
 */
export type EditHookOption = {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config?: {
        [key: string]: string;
    };
    events?: Array<string>;
};

/**
 * EditIssueCommentOption options for editing a comment
 */
export type EditIssueCommentOption = {
    body: string;
};

/**
 * EditIssueOption options for editing an issue
 */
export type EditIssueOption = {
    /**
     * deprecated
     */
    assignee?: string;
    assignees?: Array<string>;
    body?: string;
    due_date?: string;
    milestone?: number;
    ref?: string;
    state?: string;
    title?: string;
    unset_due_date?: boolean;
};

/**
 * EditLabelOption options for editing a label
 */
export type EditLabelOption = {
    color?: string;
    description?: string;
    exclusive?: boolean;
    is_archived?: boolean;
    name?: string;
};

/**
 * EditMilestoneOption options for editing a milestone
 */
export type EditMilestoneOption = {
    description?: string;
    due_on?: string;
    state?: string;
    title?: string;
};

/**
 * EditOrgOption options for editing an organization
 */
export type EditOrgOption = {
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    repo_admin_change_team_access?: boolean;
    /**
     * possible values are `public`, `limited` or `private`
     */
    visibility?: 'public' | 'limited' | 'private';
    website?: string;
};

/**
 * EditPullRequestOption options when modify pull request
 */
export type EditPullRequestOption = {
    allow_maintainer_edit?: boolean;
    assignee?: string;
    assignees?: Array<string>;
    base?: string;
    body?: string;
    due_date?: string;
    labels?: Array<number>;
    milestone?: number;
    state?: string;
    title?: string;
    unset_due_date?: boolean;
};

/**
 * EditReactionOption contain the reaction type
 */
export type EditReactionOption = {
    content?: string;
};

/**
 * EditReleaseOption options when editing a release
 */
export type EditReleaseOption = {
    body?: string;
    draft?: boolean;
    name?: string;
    prerelease?: boolean;
    tag_name?: string;
    target_commitish?: string;
};

/**
 * EditRepoOption options when editing a repository's properties
 */
export type EditRepoOption = {
    /**
     * either `true` to allow fast-forward-only merging pull requests, or `false` to prevent fast-forward-only merging.
     */
    allow_fast_forward_only_merge?: boolean;
    /**
     * either `true` to allow mark pr as merged manually, or `false` to prevent it.
     */
    allow_manual_merge?: boolean;
    /**
     * either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
     */
    allow_merge_commits?: boolean;
    /**
     * either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
     */
    allow_rebase?: boolean;
    /**
     * either `true` to allow rebase with explicit merge commits (--no-ff), or `false` to prevent rebase with explicit merge commits.
     */
    allow_rebase_explicit?: boolean;
    /**
     * either `true` to allow updating pull request branch by rebase, or `false` to prevent it.
     */
    allow_rebase_update?: boolean;
    /**
     * either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
     */
    allow_squash_merge?: boolean;
    /**
     * set to `true` to archive this repository.
     */
    archived?: boolean;
    /**
     * either `true` to enable AutodetectManualMerge, or `false` to prevent it. Note: In some special cases, misjudgments can occur.
     */
    autodetect_manual_merge?: boolean;
    /**
     * set to `true` to allow edits from maintainers by default
     */
    default_allow_maintainer_edit?: boolean;
    /**
     * sets the default branch for this repository.
     */
    default_branch?: string;
    /**
     * set to `true` to delete pr branch after merge by default
     */
    default_delete_branch_after_merge?: boolean;
    /**
     * set to a merge style to be used by this repository: "merge", "rebase", "rebase-merge", "squash", or "fast-forward-only".
     */
    default_merge_style?: string;
    /**
     * a short description of the repository.
     */
    description?: string;
    /**
     * enable prune - remove obsolete remote-tracking references when mirroring
     */
    enable_prune?: boolean;
    external_tracker?: ExternalTracker;
    external_wiki?: ExternalWiki;
    /**
     * either `true` to enable actions unit, or `false` to disable them.
     */
    has_actions?: boolean;
    /**
     * either `true` to enable issues for this repository or `false` to disable them.
     */
    has_issues?: boolean;
    /**
     * either `true` to enable packages unit, or `false` to disable them.
     */
    has_packages?: boolean;
    /**
     * either `true` to enable project unit, or `false` to disable them.
     */
    has_projects?: boolean;
    /**
     * either `true` to allow pull requests, or `false` to prevent pull request.
     */
    has_pull_requests?: boolean;
    /**
     * either `true` to enable releases unit, or `false` to disable them.
     */
    has_releases?: boolean;
    /**
     * either `true` to enable the wiki for this repository or `false` to disable it.
     */
    has_wiki?: boolean;
    /**
     * either `true` to ignore whitespace for conflicts, or `false` to not ignore whitespace.
     */
    ignore_whitespace_conflicts?: boolean;
    internal_tracker?: InternalTracker;
    /**
     * set to a string like `8h30m0s` to set the mirror interval time
     */
    mirror_interval?: string;
    /**
     * name of the repository
     */
    name?: string;
    /**
     * either `true` to make the repository private or `false` to make it public.
     * Note: you will get a 422 error if the organization restricts changing repository visibility to organization
     * owners and a non-owner tries to change the value of private.
     */
    private?: boolean;
    /**
     * `repo` to only allow repo-level projects, `owner` to only allow owner projects, `all` to allow both.
     */
    projects_mode?: string;
    /**
     * either `true` to make this repository a template or `false` to make it a normal repository
     */
    template?: boolean;
    /**
     * a URL with more information about the repository.
     */
    website?: string;
};

/**
 * EditTagProtectionOption options for editing a tag protection
 */
export type EditTagProtectionOption = {
    name_pattern?: string;
    whitelist_teams?: Array<string>;
    whitelist_usernames?: Array<string>;
};

/**
 * EditTeamOption options for editing a team
 */
export type EditTeamOption = {
    can_create_org_repo?: boolean;
    description?: string;
    includes_all_repositories?: boolean;
    name: string;
    permission?: 'read' | 'write' | 'admin';
    units?: Array<string>;
    units_map?: {
        [key: string]: string;
    };
};

/**
 * EditUserOption edit user options
 */
export type EditUserOption = {
    active?: boolean;
    admin?: boolean;
    allow_create_organization?: boolean;
    allow_git_hook?: boolean;
    allow_import_local?: boolean;
    description?: string;
    email?: string;
    full_name?: string;
    location?: string;
    login_name: string;
    max_repo_creation?: number;
    must_change_password?: boolean;
    password?: string;
    prohibit_login?: boolean;
    restricted?: boolean;
    source_id: number;
    visibility?: string;
    website?: string;
};

/**
 * Email an email address belonging to a user
 */
export type Email = {
    email?: string;
    primary?: boolean;
    user_id?: number;
    username?: string;
    verified?: boolean;
};

/**
 * ExternalTracker represents settings for external tracker
 */
export type ExternalTracker = {
    /**
     * External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index.
     */
    external_tracker_format?: string;
    /**
     * External Issue Tracker issue regular expression
     */
    external_tracker_regexp_pattern?: string;
    /**
     * External Issue Tracker Number Format, either `numeric`, `alphanumeric`, or `regexp`
     */
    external_tracker_style?: string;
    /**
     * URL of external issue tracker.
     */
    external_tracker_url?: string;
};

/**
 * ExternalWiki represents setting for external wiki
 */
export type ExternalWiki = {
    /**
     * URL of external wiki.
     */
    external_wiki_url?: string;
};

export type FileCommitResponse = {
    author?: CommitUser;
    committer?: CommitUser;
    created?: string;
    html_url?: string;
    message?: string;
    parents?: Array<CommitMeta>;
    sha?: string;
    tree?: CommitMeta;
    url?: string;
};

/**
 * FileDeleteResponse contains information about a repo's file that was deleted
 */
export type FileDeleteResponse = {
    commit?: FileCommitResponse;
    content?: unknown;
    verification?: PayloadCommitVerification;
};

/**
 * FileLinksResponse contains the links for a repo's file
 */
export type FileLinksResponse = {
    git?: string;
    html?: string;
    self?: string;
};

/**
 * FileResponse contains information about a repo's file
 */
export type FileResponse = {
    commit?: FileCommitResponse;
    content?: ContentsResponse;
    verification?: PayloadCommitVerification;
};

/**
 * FilesResponse contains information about multiple files from a repo
 */
export type FilesResponse = {
    commit?: FileCommitResponse;
    files?: Array<ContentsResponse>;
    verification?: PayloadCommitVerification;
};

/**
 * GPGKey a user GPG key to sign commit and tag in repository
 */
export type GpgKey = {
    can_certify?: boolean;
    can_encrypt_comms?: boolean;
    can_encrypt_storage?: boolean;
    can_sign?: boolean;
    created_at?: string;
    emails?: Array<GpgKeyEmail>;
    expires_at?: string;
    id?: number;
    key_id?: string;
    primary_key_id?: string;
    public_key?: string;
    subkeys?: Array<GpgKey>;
    verified?: boolean;
};

/**
 * GPGKeyEmail an email attached to a GPGKey
 */
export type GpgKeyEmail = {
    email?: string;
    verified?: boolean;
};

/**
 * GeneralAPISettings contains global api settings exposed by it
 */
export type GeneralApiSettings = {
    default_git_trees_per_page?: number;
    default_max_blob_size?: number;
    default_paging_num?: number;
    max_response_items?: number;
};

/**
 * GeneralAttachmentSettings contains global Attachment settings exposed by API
 */
export type GeneralAttachmentSettings = {
    allowed_types?: string;
    enabled?: boolean;
    max_files?: number;
    max_size?: number;
};

/**
 * GeneralRepoSettings contains global repository settings exposed by API
 */
export type GeneralRepoSettings = {
    http_git_disabled?: boolean;
    lfs_disabled?: boolean;
    migrations_disabled?: boolean;
    mirrors_disabled?: boolean;
    stars_disabled?: boolean;
    time_tracking_disabled?: boolean;
};

/**
 * GeneralUISettings contains global ui settings exposed by API
 */
export type GeneralUiSettings = {
    allowed_reactions?: Array<string>;
    custom_emojis?: Array<string>;
    default_theme?: string;
};

/**
 * GenerateRepoOption options when creating repository using a template
 */
export type GenerateRepoOption = {
    /**
     * include avatar of the template repo
     */
    avatar?: boolean;
    /**
     * Default branch of the new repository
     */
    default_branch?: string;
    /**
     * Description of the repository to create
     */
    description?: string;
    /**
     * include git content of default branch in template repo
     */
    git_content?: boolean;
    /**
     * include git hooks in template repo
     */
    git_hooks?: boolean;
    /**
     * include labels in template repo
     */
    labels?: boolean;
    /**
     * Name of the repository to create
     */
    name: string;
    /**
     * The organization or person who will own the new repository
     */
    owner: string;
    /**
     * Whether the repository is private
     */
    private?: boolean;
    /**
     * include protected branches in template repo
     */
    protected_branch?: boolean;
    /**
     * include topics in template repo
     */
    topics?: boolean;
    /**
     * include webhooks in template repo
     */
    webhooks?: boolean;
};

/**
 * GitBlobResponse represents a git blob
 */
export type GitBlobResponse = {
    content?: string;
    encoding?: string;
    sha?: string;
    size?: number;
    url?: string;
};

/**
 * GitEntry represents a git tree
 */
export type GitEntry = {
    mode?: string;
    path?: string;
    sha?: string;
    size?: number;
    type?: string;
    url?: string;
};

/**
 * GitHook represents a Git repository hook
 */
export type GitHook = {
    content?: string;
    is_active?: boolean;
    name?: string;
};

export type GitObject = {
    sha?: string;
    type?: string;
    url?: string;
};

/**
 * GitTreeResponse returns a git tree
 */
export type GitTreeResponse = {
    page?: number;
    sha?: string;
    total_count?: number;
    tree?: Array<GitEntry>;
    truncated?: boolean;
    url?: string;
};

/**
 * GitignoreTemplateInfo name and text of a gitignore template
 */
export type GitignoreTemplateInfo = {
    name?: string;
    source?: string;
};

/**
 * Hook a hook is a web hook when one repository changed
 */
export type Hook = {
    active?: boolean;
    authorization_header?: string;
    branch_filter?: string;
    config?: {
        [key: string]: string;
    };
    created_at?: string;
    events?: Array<string>;
    id?: number;
    type?: string;
    updated_at?: string;
};

/**
 * Identity for a person's identity like an author or committer
 */
export type Identity = {
    email?: string;
    name?: string;
};

/**
 * InternalTracker represents settings for internal tracker
 */
export type InternalTracker = {
    /**
     * Let only contributors track time (Built-in issue tracker)
     */
    allow_only_contributors_to_track_time?: boolean;
    /**
     * Enable dependencies for issues and pull requests (Built-in issue tracker)
     */
    enable_issue_dependencies?: boolean;
    /**
     * Enable time tracking (Built-in issue tracker)
     */
    enable_time_tracker?: boolean;
};

/**
 * Issue represents an issue in a repository
 */
export type Issue = {
    assets?: Array<Attachment>;
    assignee?: User;
    assignees?: Array<User>;
    body?: string;
    closed_at?: string;
    comments?: number;
    created_at?: string;
    due_date?: string;
    html_url?: string;
    id?: number;
    is_locked?: boolean;
    labels?: Array<Label>;
    milestone?: Milestone;
    number?: number;
    original_author?: string;
    original_author_id?: number;
    pin_order?: number;
    pull_request?: PullRequestMeta;
    ref?: string;
    repository?: RepositoryMeta;
    state?: StateType;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: User;
};

export type IssueConfig = {
    blank_issues_enabled?: boolean;
    contact_links?: Array<IssueConfigContactLink>;
};

export type IssueConfigContactLink = {
    about?: string;
    name?: string;
    url?: string;
};

export type IssueConfigValidation = {
    message?: string;
    valid?: boolean;
};

/**
 * IssueDeadline represents an issue deadline
 */
export type IssueDeadline = {
    due_date?: string;
};

/**
 * IssueFormField represents a form field
 */
export type IssueFormField = {
    attributes?: {};
    id?: string;
    type?: IssueFormFieldType;
    validations?: {};
    visible?: Array<IssueFormFieldVisible>;
};

export type IssueFormFieldType = string;

/**
 * IssueFormFieldVisible defines issue form field visible
 */
export type IssueFormFieldVisible = string;

/**
 * IssueLabelsOption a collection of labels
 */
export type IssueLabelsOption = {
    /**
     * Labels can be a list of integers representing label IDs
     * or a list of strings representing label names
     */
    labels?: Array<unknown>;
};

/**
 * IssueMeta basic issue information
 */
export type IssueMeta = {
    index?: number;
    owner?: string;
    repo?: string;
};

/**
 * IssueTemplate represents an issue template for a repository
 */
export type IssueTemplate = {
    about?: string;
    assignees?: IssueTemplateStringSlice;
    body?: Array<IssueFormField>;
    content?: string;
    file_name?: string;
    labels?: IssueTemplateStringSlice;
    name?: string;
    ref?: string;
    title?: string;
};

export type IssueTemplateStringSlice = Array<string>;

/**
 * Label a label to an issue or a pr
 */
export type Label = {
    color?: string;
    description?: string;
    exclusive?: boolean;
    id?: number;
    is_archived?: boolean;
    name?: string;
    url?: string;
};

/**
 * LabelTemplate info of a Label template
 */
export type LabelTemplate = {
    color?: string;
    description?: string;
    exclusive?: boolean;
    name?: string;
};

/**
 * LicensesInfo contains information about a License
 */
export type LicenseTemplateInfo = {
    body?: string;
    implementation?: string;
    key?: string;
    name?: string;
    url?: string;
};

/**
 * LicensesListEntry is used for the API
 */
export type LicensesTemplateListEntry = {
    key?: string;
    name?: string;
    url?: string;
};

/**
 * MarkdownOption markdown options
 */
export type MarkdownOption = {
    /**
     * URL path for rendering issue, media and file links
     * Expected format: /subpath/{user}/{repo}/src/{branch, commit, tag}/{identifier/path}/{file/dir}
     *
     * in: body
     */
    Context?: string;
    /**
     * Mode to render (markdown, comment, wiki, file)
     *
     * in: body
     */
    Mode?: string;
    /**
     * Text markdown to render
     *
     * in: body
     */
    Text?: string;
    /**
     * Is it a wiki page? (use mode=wiki instead)
     *
     * Deprecated: true
     * in: body
     */
    Wiki?: boolean;
};

/**
 * MarkupOption markup options
 */
export type MarkupOption = {
    /**
     * URL path for rendering issue, media and file links
     * Expected format: /subpath/{user}/{repo}/src/{branch, commit, tag}/{identifier/path}/{file/dir}
     *
     * in: body
     */
    Context?: string;
    /**
     * File path for detecting extension in file mode
     *
     * in: body
     */
    FilePath?: string;
    /**
     * Mode to render (markdown, comment, wiki, file)
     *
     * in: body
     */
    Mode?: string;
    /**
     * Text markup to render
     *
     * in: body
     */
    Text?: string;
    /**
     * Is it a wiki page? (use mode=wiki instead)
     *
     * Deprecated: true
     * in: body
     */
    Wiki?: boolean;
};

/**
 * MergePullRequestForm form for merging Pull Request
 */
export type MergePullRequestOption = {
    Do: 'merge' | 'rebase' | 'rebase-merge' | 'squash' | 'fast-forward-only' | 'manually-merged';
    MergeCommitID?: string;
    MergeMessageField?: string;
    MergeTitleField?: string;
    delete_branch_after_merge?: boolean;
    force_merge?: boolean;
    head_commit_id?: string;
    merge_when_checks_succeed?: boolean;
};

export type MergeUpstreamRequest = {
    branch?: string;
};

export type MergeUpstreamResponse = {
    merge_type?: string;
};

/**
 * MigrateRepoOptions options for migrating repository's
 * this is used to interact with api v1
 */
export type MigrateRepoOptions = {
    auth_password?: string;
    auth_token?: string;
    auth_username?: string;
    aws_access_key_id?: string;
    aws_secret_access_key?: string;
    clone_addr: string;
    description?: string;
    issues?: boolean;
    labels?: boolean;
    lfs?: boolean;
    lfs_endpoint?: string;
    milestones?: boolean;
    mirror?: boolean;
    mirror_interval?: string;
    private?: boolean;
    pull_requests?: boolean;
    releases?: boolean;
    repo_name: string;
    /**
     * Name of User or Organisation who will own Repo after migration
     */
    repo_owner?: string;
    service?: 'git' | 'github' | 'gitea' | 'gitlab' | 'gogs' | 'onedev' | 'gitbucket' | 'codebase';
    /**
     * deprecated (only for backwards compatibility)
     */
    uid?: number;
    wiki?: boolean;
};

/**
 * Milestone milestone is a collection of issues on one repository
 */
export type Milestone = {
    closed_at?: string;
    closed_issues?: number;
    created_at?: string;
    description?: string;
    due_on?: string;
    id?: number;
    open_issues?: number;
    state?: StateType;
    title?: string;
    updated_at?: string;
};

/**
 * NewIssuePinsAllowed represents an API response that says if new Issue Pins are allowed
 */
export type NewIssuePinsAllowed = {
    issues?: boolean;
    pull_requests?: boolean;
};

/**
 * NodeInfo contains standardized way of exposing metadata about a server running one of the distributed social networks
 */
export type NodeInfo = {
    metadata?: {
        [key: string]: unknown;
    };
    openRegistrations?: boolean;
    protocols?: Array<string>;
    services?: NodeInfoServices;
    software?: NodeInfoSoftware;
    usage?: NodeInfoUsage;
    version?: string;
};

/**
 * NodeInfoServices contains the third party sites this server can connect to via their application API
 */
export type NodeInfoServices = {
    inbound?: Array<string>;
    outbound?: Array<string>;
};

/**
 * NodeInfoSoftware contains Metadata about server software in use
 */
export type NodeInfoSoftware = {
    homepage?: string;
    name?: string;
    repository?: string;
    version?: string;
};

/**
 * NodeInfoUsage contains usage statistics for this server
 */
export type NodeInfoUsage = {
    localComments?: number;
    localPosts?: number;
    users?: NodeInfoUsageUsers;
};

/**
 * NodeInfoUsageUsers contains statistics about the users of this server
 */
export type NodeInfoUsageUsers = {
    activeHalfyear?: number;
    activeMonth?: number;
    total?: number;
};

/**
 * Note contains information related to a git note
 */
export type Note = {
    commit?: Commit;
    message?: string;
};

/**
 * NotificationCount number of unread notifications
 */
export type NotificationCount = {
    new?: number;
};

/**
 * NotificationSubject contains the notification subject (Issue/Pull/Commit)
 */
export type NotificationSubject = {
    html_url?: string;
    latest_comment_html_url?: string;
    latest_comment_url?: string;
    state?: StateType;
    title?: string;
    type?: NotifySubjectType;
    url?: string;
};

/**
 * NotificationThread expose Notification on API
 */
export type NotificationThread = {
    id?: number;
    pinned?: boolean;
    repository?: Repository;
    subject?: NotificationSubject;
    unread?: boolean;
    updated_at?: string;
    url?: string;
};

/**
 * NotifySubjectType represent type of notification subject
 */
export type NotifySubjectType = string;

export type OAuth2Application = {
    client_id?: string;
    client_secret?: string;
    confidential_client?: boolean;
    created?: string;
    id?: number;
    name?: string;
    redirect_uris?: Array<string>;
    skip_secondary_authorization?: boolean;
};

/**
 * Organization represents an organization
 */
export type Organization = {
    avatar_url?: string;
    description?: string;
    email?: string;
    full_name?: string;
    id?: number;
    location?: string;
    name?: string;
    repo_admin_change_team_access?: boolean;
    /**
     * deprecated
     */
    username?: string;
    visibility?: string;
    website?: string;
};

/**
 * OrganizationPermissions list different users permissions on an organization
 */
export type OrganizationPermissions = {
    can_create_repository?: boolean;
    can_read?: boolean;
    can_write?: boolean;
    is_admin?: boolean;
    is_owner?: boolean;
};

/**
 * PRBranchInfo information about a branch
 */
export type PrBranchInfo = {
    label?: string;
    ref?: string;
    repo?: Repository;
    repo_id?: number;
    sha?: string;
};

/**
 * Package represents a package
 */
export type Package = {
    created_at?: string;
    creator?: User;
    html_url?: string;
    id?: number;
    name?: string;
    owner?: User;
    repository?: Repository;
    type?: string;
    version?: string;
};

/**
 * PackageFile represents a package file
 */
export type PackageFile = {
    Size?: number;
    id?: number;
    md5?: string;
    name?: string;
    sha1?: string;
    sha256?: string;
    sha512?: string;
};

/**
 * PayloadCommit represents a commit
 */
export type PayloadCommit = {
    added?: Array<string>;
    author?: PayloadUser;
    committer?: PayloadUser;
    /**
     * sha1 hash of the commit
     */
    id?: string;
    message?: string;
    modified?: Array<string>;
    removed?: Array<string>;
    timestamp?: string;
    url?: string;
    verification?: PayloadCommitVerification;
};

/**
 * PayloadCommitVerification represents the GPG verification of a commit
 */
export type PayloadCommitVerification = {
    payload?: string;
    reason?: string;
    signature?: string;
    signer?: PayloadUser;
    verified?: boolean;
};

/**
 * PayloadUser represents the author or committer of a commit
 */
export type PayloadUser = {
    email?: string;
    /**
     * Full name of the commit author
     */
    name?: string;
    username?: string;
};

/**
 * Permission represents a set of permissions
 */
export type Permission = {
    admin?: boolean;
    pull?: boolean;
    push?: boolean;
};

/**
 * PublicKey publickey is a user key to push code to repository
 */
export type PublicKey = {
    created_at?: string;
    fingerprint?: string;
    id?: number;
    key?: string;
    key_type?: string;
    read_only?: boolean;
    title?: string;
    url?: string;
    user?: User;
};

/**
 * PullRequest represents a pull request
 */
export type PullRequest = {
    additions?: number;
    allow_maintainer_edit?: boolean;
    assignee?: User;
    assignees?: Array<User>;
    base?: PrBranchInfo;
    body?: string;
    changed_files?: number;
    closed_at?: string;
    comments?: number;
    created_at?: string;
    deletions?: number;
    diff_url?: string;
    draft?: boolean;
    due_date?: string;
    head?: PrBranchInfo;
    html_url?: string;
    id?: number;
    is_locked?: boolean;
    labels?: Array<Label>;
    merge_base?: string;
    merge_commit_sha?: string;
    mergeable?: boolean;
    merged?: boolean;
    merged_at?: string;
    merged_by?: User;
    milestone?: Milestone;
    number?: number;
    patch_url?: string;
    pin_order?: number;
    requested_reviewers?: Array<User>;
    requested_reviewers_teams?: Array<Team>;
    /**
     * number of review comments made on the diff of a PR review (not including comments on commits or issues in a PR)
     */
    review_comments?: number;
    state?: StateType;
    title?: string;
    updated_at?: string;
    url?: string;
    user?: User;
};

/**
 * PullRequestMeta PR info if an issue is a PR
 */
export type PullRequestMeta = {
    draft?: boolean;
    html_url?: string;
    merged?: boolean;
    merged_at?: string;
};

/**
 * PullReview represents a pull request review
 */
export type PullReview = {
    body?: string;
    comments_count?: number;
    commit_id?: string;
    dismissed?: boolean;
    html_url?: string;
    id?: number;
    official?: boolean;
    pull_request_url?: string;
    stale?: boolean;
    state?: ReviewStateType;
    submitted_at?: string;
    team?: Team;
    updated_at?: string;
    user?: User;
};

/**
 * PullReviewComment represents a comment on a pull request review
 */
export type PullReviewComment = {
    body?: string;
    commit_id?: string;
    created_at?: string;
    diff_hunk?: string;
    html_url?: string;
    id?: number;
    original_commit_id?: string;
    original_position?: number;
    path?: string;
    position?: number;
    pull_request_review_id?: number;
    pull_request_url?: string;
    resolver?: User;
    updated_at?: string;
    user?: User;
};

/**
 * PullReviewRequestOptions are options to add or remove pull review requests
 */
export type PullReviewRequestOptions = {
    reviewers?: Array<string>;
    team_reviewers?: Array<string>;
};

/**
 * PushMirror represents information of a push mirror
 */
export type PushMirror = {
    created?: string;
    interval?: string;
    last_error?: string;
    last_update?: string;
    remote_address?: string;
    remote_name?: string;
    repo_name?: string;
    sync_on_commit?: boolean;
};

/**
 * Reaction contain one reaction
 */
export type Reaction = {
    content?: string;
    created_at?: string;
    user?: User;
};

export type Reference = {
    object?: GitObject;
    ref?: string;
    url?: string;
};

/**
 * Release represents a repository release
 */
export type Release = {
    assets?: Array<Attachment>;
    author?: User;
    body?: string;
    created_at?: string;
    draft?: boolean;
    html_url?: string;
    id?: number;
    name?: string;
    prerelease?: boolean;
    published_at?: string;
    tag_name?: string;
    tarball_url?: string;
    target_commitish?: string;
    upload_url?: string;
    url?: string;
    zipball_url?: string;
};

/**
 * RenameOrgOption options when renaming an organization
 */
export type RenameOrgOption = {
    /**
     * New username for this org. This name cannot be in use yet by any other user.
     */
    new_name: string;
};

/**
 * RenameUserOption options when renaming a user
 */
export type RenameUserOption = {
    /**
     * New username for this user. This name cannot be in use yet by any other user.
     */
    new_username: string;
};

/**
 * RepoCollaboratorPermission to get repository permission for a collaborator
 */
export type RepoCollaboratorPermission = {
    permission?: string;
    role_name?: string;
    user?: User;
};

export type RepoCommit = {
    author?: CommitUser;
    committer?: CommitUser;
    message?: string;
    tree?: CommitMeta;
    url?: string;
    verification?: PayloadCommitVerification;
};

/**
 * RepoTopicOptions a collection of repo topic names
 */
export type RepoTopicOptions = {
    /**
     * list of topic names
     */
    topics?: Array<string>;
};

/**
 * RepoTransfer represents a pending repo transfer
 */
export type RepoTransfer = {
    doer?: User;
    recipient?: User;
    teams?: Array<Team>;
};

/**
 * Repository represents a repository
 */
export type Repository = {
    allow_fast_forward_only_merge?: boolean;
    allow_merge_commits?: boolean;
    allow_rebase?: boolean;
    allow_rebase_explicit?: boolean;
    allow_rebase_update?: boolean;
    allow_squash_merge?: boolean;
    archived?: boolean;
    archived_at?: string;
    avatar_url?: string;
    clone_url?: string;
    created_at?: string;
    default_allow_maintainer_edit?: boolean;
    default_branch?: string;
    default_delete_branch_after_merge?: boolean;
    default_merge_style?: string;
    description?: string;
    empty?: boolean;
    external_tracker?: ExternalTracker;
    external_wiki?: ExternalWiki;
    fork?: boolean;
    forks_count?: number;
    full_name?: string;
    has_actions?: boolean;
    has_issues?: boolean;
    has_packages?: boolean;
    has_projects?: boolean;
    has_pull_requests?: boolean;
    has_releases?: boolean;
    has_wiki?: boolean;
    html_url?: string;
    id?: number;
    ignore_whitespace_conflicts?: boolean;
    internal?: boolean;
    internal_tracker?: InternalTracker;
    language?: string;
    languages_url?: string;
    licenses?: Array<string>;
    link?: string;
    mirror?: boolean;
    mirror_interval?: string;
    mirror_updated?: string;
    name?: string;
    /**
     * ObjectFormatName of the underlying git repository
     */
    object_format_name?: 'sha1' | 'sha256';
    open_issues_count?: number;
    open_pr_counter?: number;
    original_url?: string;
    owner?: User;
    parent?: Repository;
    permissions?: Permission;
    private?: boolean;
    projects_mode?: string;
    release_counter?: number;
    repo_transfer?: RepoTransfer;
    size?: number;
    ssh_url?: string;
    stars_count?: number;
    template?: boolean;
    topics?: Array<string>;
    updated_at?: string;
    url?: string;
    watchers_count?: number;
    website?: string;
};

/**
 * RepositoryMeta basic repository information
 */
export type RepositoryMeta = {
    full_name?: string;
    id?: number;
    name?: string;
    owner?: string;
};

/**
 * ReviewStateType review state type
 */
export type ReviewStateType = string;

/**
 * SearchResults results of a successful search
 */
export type SearchResults = {
    data?: Array<Repository>;
    ok?: boolean;
};

/**
 * Secret represents a secret
 */
export type Secret = {
    created_at?: string;
    /**
     * the secret's name
     */
    name?: string;
};

/**
 * ServerVersion wraps the version of the server
 */
export type ServerVersion = {
    version?: string;
};

/**
 * StateType issue state type
 */
export type StateType = string;

/**
 * StopWatch represent a running stopwatch
 */
export type StopWatch = {
    created?: string;
    duration?: string;
    issue_index?: number;
    issue_title?: string;
    repo_name?: string;
    repo_owner_name?: string;
    seconds?: number;
};

/**
 * SubmitPullReviewOptions are options to submit a pending pull review
 */
export type SubmitPullReviewOptions = {
    body?: string;
    event?: ReviewStateType;
};

/**
 * Tag represents a repository tag
 */
export type Tag = {
    commit?: CommitMeta;
    id?: string;
    message?: string;
    name?: string;
    tarball_url?: string;
    zipball_url?: string;
};

/**
 * TagProtection represents a tag protection
 */
export type TagProtection = {
    created_at?: string;
    id?: number;
    name_pattern?: string;
    updated_at?: string;
    whitelist_teams?: Array<string>;
    whitelist_usernames?: Array<string>;
};

/**
 * Team represents a team in an organization
 */
export type Team = {
    can_create_org_repo?: boolean;
    description?: string;
    id?: number;
    includes_all_repositories?: boolean;
    name?: string;
    organization?: Organization;
    permission?: 'none' | 'read' | 'write' | 'admin' | 'owner';
    units?: Array<string>;
    units_map?: {
        [key: string]: string;
    };
};

/**
 * TimeStamp defines a timestamp
 */
export type TimeStamp = number;

/**
 * TimelineComment represents a timeline comment (comment of any type) on a commit or issue
 */
export type TimelineComment = {
    assignee?: User;
    assignee_team?: Team;
    body?: string;
    created_at?: string;
    dependent_issue?: Issue;
    html_url?: string;
    id?: number;
    issue_url?: string;
    label?: Label;
    milestone?: Milestone;
    new_ref?: string;
    new_title?: string;
    old_milestone?: Milestone;
    old_project_id?: number;
    old_ref?: string;
    old_title?: string;
    project_id?: number;
    pull_request_url?: string;
    ref_action?: string;
    ref_comment?: Comment;
    /**
     * commit SHA where issue/PR was referenced
     */
    ref_commit_sha?: string;
    ref_issue?: Issue;
    /**
     * whether the assignees were removed or added
     */
    removed_assignee?: boolean;
    resolve_doer?: User;
    review_id?: number;
    tracked_time?: TrackedTime;
    type?: string;
    updated_at?: string;
    user?: User;
};

/**
 * TopicName a list of repo topic names
 */
export type TopicName = {
    topics?: Array<string>;
};

/**
 * TopicResponse for returning topics
 */
export type TopicResponse = {
    created?: string;
    id?: number;
    repo_count?: number;
    topic_name?: string;
    updated?: string;
};

/**
 * TrackedTime worked time for an issue / pr
 */
export type TrackedTime = {
    created?: string;
    id?: number;
    issue?: Issue;
    /**
     * deprecated (only for backwards compatibility)
     */
    issue_id?: number;
    /**
     * Time in seconds
     */
    time?: number;
    /**
     * deprecated (only for backwards compatibility)
     */
    user_id?: number;
    user_name?: string;
};

/**
 * TransferRepoOption options when transfer a repository's ownership
 */
export type TransferRepoOption = {
    new_owner: string;
    /**
     * ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
     */
    team_ids?: Array<number>;
};

/**
 * UpdateBranchProtectionPriories a list to update the branch protection rule priorities
 */
export type UpdateBranchProtectionPriories = {
    ids?: Array<number>;
};

/**
 * UpdateBranchRepoOption options when updating a branch in a repository
 */
export type UpdateBranchRepoOption = {
    /**
     * New branch name
     */
    name: string;
};

/**
 * UpdateFileOptions options for updating files
 * Note: `author` and `committer` are optional (if only one is given, it will be used for the other, otherwise the authenticated user will be used)
 */
export type UpdateFileOptions = {
    author?: Identity;
    /**
     * branch (optional) to base this file from. if not given, the default branch is used
     */
    branch?: string;
    committer?: Identity;
    /**
     * content must be base64 encoded
     */
    content: string;
    dates?: CommitDateOptions;
    /**
     * from_path (optional) is the path of the original file which will be moved/renamed to the path in the URL
     */
    from_path?: string;
    /**
     * message (optional) for the commit of this file. if not supplied, a default message will be used
     */
    message?: string;
    /**
     * new_branch (optional) will make a new branch from `branch` before creating the file
     */
    new_branch?: string;
    /**
     * sha is the SHA for the file that already exists
     */
    sha: string;
    /**
     * Add a Signed-off-by trailer by the committer at the end of the commit log message.
     */
    signoff?: boolean;
};

/**
 * UpdateRepoAvatarUserOption options when updating the repo avatar
 */
export type UpdateRepoAvatarOption = {
    /**
     * image must be base64 encoded
     */
    image?: string;
};

/**
 * UpdateUserAvatarUserOption options when updating the user avatar
 */
export type UpdateUserAvatarOption = {
    /**
     * image must be base64 encoded
     */
    image?: string;
};

/**
 * UpdateVariableOption the option when updating variable
 */
export type UpdateVariableOption = {
    /**
     * New name for the variable. If the field is empty, the variable name won't be updated.
     */
    name?: string;
    /**
     * Value of the variable to update
     */
    value: string;
};

/**
 * User represents a user
 */
export type User = {
    /**
     * Is user active
     */
    active?: boolean;
    /**
     * URL to the user's avatar
     */
    avatar_url?: string;
    created?: string;
    /**
     * the user's description
     */
    description?: string;
    email?: string;
    /**
     * user counts
     */
    followers_count?: number;
    following_count?: number;
    /**
     * the user's full name
     */
    full_name?: string;
    /**
     * URL to the user's gitea page
     */
    html_url?: string;
    /**
     * the user's id
     */
    id?: number;
    /**
     * Is the user an administrator
     */
    is_admin?: boolean;
    /**
     * User locale
     */
    language?: string;
    last_login?: string;
    /**
     * the user's location
     */
    location?: string;
    /**
     * the user's username
     */
    login?: string;
    /**
     * the user's authentication sign-in name.
     */
    login_name?: string;
    /**
     * Is user login prohibited
     */
    prohibit_login?: boolean;
    /**
     * Is user restricted
     */
    restricted?: boolean;
    /**
     * The ID of the user's Authentication Source
     */
    source_id?: number;
    starred_repos_count?: number;
    /**
     * User visibility level option: public, limited, private
     */
    visibility?: string;
    /**
     * the user's website
     */
    website?: string;
};

/**
 * UserBadgeOption options for link between users and badges
 */
export type UserBadgeOption = {
    badge_slugs?: Array<string>;
};

/**
 * UserHeatmapData represents the data needed to create a heatmap
 */
export type UserHeatmapData = {
    contributions?: number;
    timestamp?: TimeStamp;
};

/**
 * UserSettings represents user settings
 */
export type UserSettings = {
    description?: string;
    diff_view_style?: string;
    full_name?: string;
    hide_activity?: boolean;
    /**
     * Privacy
     */
    hide_email?: boolean;
    language?: string;
    location?: string;
    theme?: string;
    website?: string;
};

/**
 * UserSettingsOptions represents options to change user settings
 */
export type UserSettingsOptions = {
    description?: string;
    diff_view_style?: string;
    full_name?: string;
    hide_activity?: boolean;
    /**
     * Privacy
     */
    hide_email?: boolean;
    language?: string;
    location?: string;
    theme?: string;
    website?: string;
};

/**
 * WatchInfo represents an API watch status of one repository
 */
export type WatchInfo = {
    created_at?: string;
    ignored?: boolean;
    reason?: unknown;
    repository_url?: string;
    subscribed?: boolean;
    url?: string;
};

/**
 * WikiCommit page commit/revision
 */
export type WikiCommit = {
    author?: CommitUser;
    commiter?: CommitUser;
    message?: string;
    sha?: string;
};

/**
 * WikiCommitList commit/revision list
 */
export type WikiCommitList = {
    commits?: Array<WikiCommit>;
    count?: number;
};

/**
 * WikiPage a wiki page
 */
export type WikiPage = {
    commit_count?: number;
    /**
     * Page content, base64 encoded
     */
    content_base64?: string;
    footer?: string;
    html_url?: string;
    last_commit?: WikiCommit;
    sidebar?: string;
    sub_url?: string;
    title?: string;
};

/**
 * WikiPageMetaData wiki page meta information
 */
export type WikiPageMetaData = {
    html_url?: string;
    last_commit?: WikiCommit;
    sub_url?: string;
    title?: string;
};

export type ActivitypubPersonData = {
    body?: never;
    path: {
        /**
         * user ID of the user
         */
        'user-id': number;
    };
    query?: never;
    url: '/activitypub/user-id/{user-id}';
};

export type ActivitypubPersonResponses = {
    /**
     * ActivityPub
     */
    200: ActivityPub;
};

export type ActivitypubPersonResponse = ActivitypubPersonResponses[keyof ActivitypubPersonResponses];

export type ActivitypubPersonInboxData = {
    body?: never;
    path: {
        /**
         * user ID of the user
         */
        'user-id': number;
    };
    query?: never;
    url: '/activitypub/user-id/{user-id}/inbox';
};

export type ActivitypubPersonInboxResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminCronListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/cron';
};

export type AdminCronListErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminCronListResponses = {
    /**
     * CronList
     */
    200: Array<Cron>;
};

export type AdminCronListResponse = AdminCronListResponses[keyof AdminCronListResponses];

export type AdminCronRunData = {
    body?: never;
    path: {
        /**
         * task to run
         */
        task: string;
    };
    query?: never;
    url: '/admin/cron/{task}';
};

export type AdminCronRunErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type AdminCronRunResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminGetAllEmailsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/emails';
};

export type AdminGetAllEmailsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminGetAllEmailsResponses = {
    /**
     * EmailList
     */
    200: Array<Email>;
};

export type AdminGetAllEmailsResponse = AdminGetAllEmailsResponses[keyof AdminGetAllEmailsResponses];

export type AdminSearchEmailsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * keyword
         */
        q?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/emails/search';
};

export type AdminSearchEmailsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminSearchEmailsResponses = {
    /**
     * EmailList
     */
    200: Array<Email>;
};

export type AdminSearchEmailsResponse = AdminSearchEmailsResponses[keyof AdminSearchEmailsResponses];

export type AdminListHooksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * system, default or both kinds of webhooks
         */
        type?: 'system' | 'default' | 'all';
    };
    url: '/admin/hooks';
};

export type AdminListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type AdminListHooksResponse = AdminListHooksResponses[keyof AdminListHooksResponses];

export type AdminCreateHookData = {
    body: CreateHookOption;
    path?: never;
    query?: never;
    url: '/admin/hooks';
};

export type AdminCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type AdminCreateHookResponse = AdminCreateHookResponses[keyof AdminCreateHookResponses];

export type AdminDeleteHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/admin/hooks/{id}';
};

export type AdminDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminGetHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/admin/hooks/{id}';
};

export type AdminGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type AdminGetHookResponse = AdminGetHookResponses[keyof AdminGetHookResponses];

export type AdminEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * id of the hook to update
         */
        id: number;
    };
    query?: never;
    url: '/admin/hooks/{id}';
};

export type AdminEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type AdminEditHookResponse = AdminEditHookResponses[keyof AdminEditHookResponses];

export type AdminGetAllOrgsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/orgs';
};

export type AdminGetAllOrgsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminGetAllOrgsResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type AdminGetAllOrgsResponse = AdminGetAllOrgsResponses[keyof AdminGetAllOrgsResponses];

export type AdminGetRunnerRegistrationTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/admin/runners/registration-token';
};

export type AdminGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is response related to registration token
     */
    200: unknown;
};

export type AdminUnadoptedListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * pattern of repositories to search for
         */
        pattern?: string;
    };
    url: '/admin/unadopted';
};

export type AdminUnadoptedListErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminUnadoptedListResponses = {
    /**
     * StringSlice
     */
    200: Array<string>;
};

export type AdminUnadoptedListResponse = AdminUnadoptedListResponses[keyof AdminUnadoptedListResponses];

export type AdminDeleteUnadoptedRepositoryData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/admin/unadopted/{owner}/{repo}';
};

export type AdminDeleteUnadoptedRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminDeleteUnadoptedRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminAdoptRepositoryData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/admin/unadopted/{owner}/{repo}';
};

export type AdminAdoptRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type AdminAdoptRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminSearchUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * ID of the user's login source to search for
         */
        source_id?: number;
        /**
         * user's login name to search for
         */
        login_name?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/admin/users';
};

export type AdminSearchUsersErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminSearchUsersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type AdminSearchUsersResponse = AdminSearchUsersResponses[keyof AdminSearchUsersResponses];

export type AdminCreateUserData = {
    body?: CreateUserOption;
    path?: never;
    query?: never;
    url: '/admin/users';
};

export type AdminCreateUserErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminCreateUserResponses = {
    /**
     * User
     */
    201: User;
};

export type AdminCreateUserResponse = AdminCreateUserResponses[keyof AdminCreateUserResponses];

export type AdminDeleteUserData = {
    body?: never;
    path: {
        /**
         * username of user to delete
         */
        username: string;
    };
    query?: {
        /**
         * purge the user from the system completely
         */
        purge?: boolean;
    };
    url: '/admin/users/{username}';
};

export type AdminDeleteUserErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminDeleteUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminEditUserData = {
    body?: EditUserOption;
    path: {
        /**
         * username of user to edit
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}';
};

export type AdminEditUserErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminEditUserResponses = {
    /**
     * User
     */
    200: User;
};

export type AdminEditUserResponse = AdminEditUserResponses[keyof AdminEditUserResponses];

export type AdminDeleteUserBadgesData = {
    body?: UserBadgeOption;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/badges';
};

export type AdminDeleteUserBadgesErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminDeleteUserBadgesResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminListUserBadgesData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/badges';
};

export type AdminListUserBadgesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type AdminListUserBadgesResponses = {
    /**
     * BadgeList
     */
    200: Array<Badge>;
};

export type AdminListUserBadgesResponse = AdminListUserBadgesResponses[keyof AdminListUserBadgesResponses];

export type AdminAddUserBadgesData = {
    body?: UserBadgeOption;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/badges';
};

export type AdminAddUserBadgesErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type AdminAddUserBadgesResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminCreatePublicKeyData = {
    body?: CreateKeyOption;
    path: {
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/keys';
};

export type AdminCreatePublicKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminCreatePublicKeyResponses = {
    /**
     * PublicKey
     */
    201: PublicKey;
};

export type AdminCreatePublicKeyResponse = AdminCreatePublicKeyResponses[keyof AdminCreatePublicKeyResponses];

export type AdminDeleteUserPublicKeyData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
        /**
         * id of the key to delete
         */
        id: number;
    };
    query?: never;
    url: '/admin/users/{username}/keys/{id}';
};

export type AdminDeleteUserPublicKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type AdminDeleteUserPublicKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminCreateOrgData = {
    body: CreateOrgOption;
    path: {
        /**
         * username of the user that will own the created organization
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/orgs';
};

export type AdminCreateOrgErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminCreateOrgResponses = {
    /**
     * Organization
     */
    201: Organization;
};

export type AdminCreateOrgResponse = AdminCreateOrgResponses[keyof AdminCreateOrgResponses];

export type AdminRenameUserData = {
    body: RenameUserOption;
    path: {
        /**
         * existing username of user
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/rename';
};

export type AdminRenameUserErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminRenameUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type AdminCreateRepoData = {
    body: CreateRepoOption;
    path: {
        /**
         * username of the user. This user will own the created repository
         */
        username: string;
    };
    query?: never;
    url: '/admin/users/{username}/repos';
};

export type AdminCreateRepoErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type AdminCreateRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type AdminCreateRepoResponse = AdminCreateRepoResponses[keyof AdminCreateRepoResponses];

export type ListGitignoresTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/gitignore/templates';
};

export type ListGitignoresTemplatesResponses = {
    /**
     * GitignoreTemplateList
     */
    200: Array<string>;
};

export type ListGitignoresTemplatesResponse = ListGitignoresTemplatesResponses[keyof ListGitignoresTemplatesResponses];

export type GetGitignoreTemplateInfoData = {
    body?: never;
    path: {
        /**
         * name of the template
         */
        name: string;
    };
    query?: never;
    url: '/gitignore/templates/{name}';
};

export type GetGitignoreTemplateInfoErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetGitignoreTemplateInfoResponses = {
    /**
     * GitignoreTemplateInfo
     */
    200: GitignoreTemplateInfo;
};

export type GetGitignoreTemplateInfoResponse = GetGitignoreTemplateInfoResponses[keyof GetGitignoreTemplateInfoResponses];

export type ListLabelTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/label/templates';
};

export type ListLabelTemplatesResponses = {
    /**
     * LabelTemplateList
     */
    200: Array<string>;
};

export type ListLabelTemplatesResponse = ListLabelTemplatesResponses[keyof ListLabelTemplatesResponses];

export type GetLabelTemplateInfoData = {
    body?: never;
    path: {
        /**
         * name of the template
         */
        name: string;
    };
    query?: never;
    url: '/label/templates/{name}';
};

export type GetLabelTemplateInfoErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetLabelTemplateInfoResponses = {
    /**
     * LabelTemplateInfo
     */
    200: Array<LabelTemplate>;
};

export type GetLabelTemplateInfoResponse = GetLabelTemplateInfoResponses[keyof GetLabelTemplateInfoResponses];

export type ListLicenseTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/licenses';
};

export type ListLicenseTemplatesResponses = {
    /**
     * LicenseTemplateList
     */
    200: Array<LicensesTemplateListEntry>;
};

export type ListLicenseTemplatesResponse = ListLicenseTemplatesResponses[keyof ListLicenseTemplatesResponses];

export type GetLicenseTemplateInfoData = {
    body?: never;
    path: {
        /**
         * name of the license
         */
        name: string;
    };
    query?: never;
    url: '/licenses/{name}';
};

export type GetLicenseTemplateInfoErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetLicenseTemplateInfoResponses = {
    /**
     * LicenseTemplateInfo
     */
    200: LicenseTemplateInfo;
};

export type GetLicenseTemplateInfoResponse = GetLicenseTemplateInfoResponses[keyof GetLicenseTemplateInfoResponses];

export type RenderMarkdownData = {
    body?: MarkdownOption;
    path?: never;
    query?: never;
    url: '/markdown';
};

export type RenderMarkdownErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RenderMarkdownResponses = {
    /**
     * MarkdownRender is a rendered markdown document
     */
    200: string;
};

export type RenderMarkdownResponse = RenderMarkdownResponses[keyof RenderMarkdownResponses];

export type RenderMarkdownRawData = {
    /**
     * Request body to render
     */
    body: string;
    path?: never;
    query?: never;
    url: '/markdown/raw';
};

export type RenderMarkdownRawErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RenderMarkdownRawResponses = {
    /**
     * MarkdownRender is a rendered markdown document
     */
    200: string;
};

export type RenderMarkdownRawResponse = RenderMarkdownRawResponses[keyof RenderMarkdownRawResponses];

export type RenderMarkupData = {
    body?: MarkupOption;
    path?: never;
    query?: never;
    url: '/markup';
};

export type RenderMarkupErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RenderMarkupResponses = {
    /**
     * MarkupRender is a rendered markup document
     */
    200: string;
};

export type RenderMarkupResponse = RenderMarkupResponses[keyof RenderMarkupResponses];

export type GetNodeInfoData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/nodeinfo';
};

export type GetNodeInfoResponses = {
    /**
     * NodeInfo
     */
    200: NodeInfo;
};

export type GetNodeInfoResponse = GetNodeInfoResponses[keyof GetNodeInfoResponses];

export type NotifyGetListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * If true, show notifications marked as read. Default value is false
         */
        all?: boolean;
        /**
         * Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned.
         */
        'status-types'?: Array<string>;
        /**
         * filter notifications by subject type
         */
        'subject-type'?: Array<'issue' | 'pull' | 'commit' | 'repository'>;
        /**
         * Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/notifications';
};

export type NotifyGetListResponses = {
    /**
     * NotificationThreadList
     */
    200: Array<NotificationThread>;
};

export type NotifyGetListResponse = NotifyGetListResponses[keyof NotifyGetListResponses];

export type NotifyReadListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         */
        last_read_at?: string;
        /**
         * If true, mark all notifications on this repo. Default value is false
         */
        all?: string;
        /**
         * Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         */
        'status-types'?: Array<string>;
        /**
         * Status to mark notifications as, Defaults to read.
         */
        'to-status'?: string;
    };
    url: '/notifications';
};

export type NotifyReadListResponses = {
    /**
     * NotificationThreadList
     */
    205: Array<NotificationThread>;
};

export type NotifyReadListResponse = NotifyReadListResponses[keyof NotifyReadListResponses];

export type NotifyNewAvailableData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/notifications/new';
};

export type NotifyNewAvailableResponses = {
    /**
     * Number of unread notifications
     */
    200: NotificationCount;
};

export type NotifyNewAvailableResponse = NotifyNewAvailableResponses[keyof NotifyNewAvailableResponses];

export type NotifyGetThreadData = {
    body?: never;
    path: {
        /**
         * id of notification thread
         */
        id: string;
    };
    query?: never;
    url: '/notifications/threads/{id}';
};

export type NotifyGetThreadErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type NotifyGetThreadResponses = {
    /**
     * NotificationThread
     */
    200: NotificationThread;
};

export type NotifyGetThreadResponse = NotifyGetThreadResponses[keyof NotifyGetThreadResponses];

export type NotifyReadThreadData = {
    body?: never;
    path: {
        /**
         * id of notification thread
         */
        id: string;
    };
    query?: {
        /**
         * Status to mark notifications as
         */
        'to-status'?: string;
    };
    url: '/notifications/threads/{id}';
};

export type NotifyReadThreadErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type NotifyReadThreadResponses = {
    /**
     * NotificationThread
     */
    205: NotificationThread;
};

export type NotifyReadThreadResponse = NotifyReadThreadResponses[keyof NotifyReadThreadResponses];

export type CreateOrgRepoDeprecatedData = {
    body?: CreateRepoOption;
    path: {
        /**
         * name of organization
         */
        org: string;
    };
    query?: never;
    url: '/org/{org}/repos';
};

export type CreateOrgRepoDeprecatedErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type CreateOrgRepoDeprecatedResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type CreateOrgRepoDeprecatedResponse = CreateOrgRepoDeprecatedResponses[keyof CreateOrgRepoDeprecatedResponses];

export type OrgGetAllData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs';
};

export type OrgGetAllResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type OrgGetAllResponse = OrgGetAllResponses[keyof OrgGetAllResponses];

export type OrgCreateData = {
    body: CreateOrgOption;
    path?: never;
    query?: never;
    url: '/orgs';
};

export type OrgCreateErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type OrgCreateResponses = {
    /**
     * Organization
     */
    201: Organization;
};

export type OrgCreateResponse = OrgCreateResponses[keyof OrgCreateResponses];

export type OrgDeleteData = {
    body?: never;
    path: {
        /**
         * organization that is to be deleted
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}';
};

export type OrgDeleteErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgDeleteResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgGetData = {
    body?: never;
    path: {
        /**
         * name of the organization to get
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}';
};

export type OrgGetErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgGetResponses = {
    /**
     * Organization
     */
    200: Organization;
};

export type OrgGetResponse = OrgGetResponses[keyof OrgGetResponses];

export type OrgEditData = {
    body: EditOrgOption;
    path: {
        /**
         * name of the organization to edit
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}';
};

export type OrgEditErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgEditResponses = {
    /**
     * Organization
     */
    200: Organization;
};

export type OrgEditResponse = OrgEditResponses[keyof OrgEditResponses];

export type OrgGetRunnerRegistrationTokenData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/runners/registration-token';
};

export type OrgGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is response related to registration token
     */
    200: unknown;
};

export type OrgListActionsSecretsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/actions/secrets';
};

export type OrgListActionsSecretsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListActionsSecretsResponses = {
    /**
     * SecretList
     */
    200: Array<Secret>;
};

export type OrgListActionsSecretsResponse = OrgListActionsSecretsResponses[keyof OrgListActionsSecretsResponses];

export type DeleteOrgSecretData = {
    body?: never;
    path: {
        /**
         * name of organization
         */
        org: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/secrets/{secretname}';
};

export type DeleteOrgSecretErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeleteOrgSecretResponses = {
    /**
     * delete one secret of the organization
     */
    204: unknown;
};

export type UpdateOrgSecretData = {
    body?: CreateOrUpdateSecretOption;
    path: {
        /**
         * name of organization
         */
        org: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/secrets/{secretname}';
};

export type UpdateOrgSecretErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UpdateOrgSecretResponses = {
    /**
     * response when creating a secret
     */
    201: unknown;
    /**
     * response when updating a secret
     */
    204: unknown;
};

export type GetOrgVariablesListData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/actions/variables';
};

export type GetOrgVariablesListErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetOrgVariablesListResponses = {
    /**
     * VariableList
     */
    200: Array<ActionVariable>;
};

export type GetOrgVariablesListResponse = GetOrgVariablesListResponses[keyof GetOrgVariablesListResponses];

export type DeleteOrgVariableData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type DeleteOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeleteOrgVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
    /**
     * response when deleting a variable
     */
    201: unknown;
    /**
     * response when deleting a variable
     */
    204: unknown;
};

export type DeleteOrgVariableResponse = DeleteOrgVariableResponses[keyof DeleteOrgVariableResponses];

export type GetOrgVariableData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type GetOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetOrgVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
};

export type GetOrgVariableResponse = GetOrgVariableResponses[keyof GetOrgVariableResponses];

export type CreateOrgVariableData = {
    body?: CreateVariableOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type CreateOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type CreateOrgVariableResponses = {
    /**
     * response when creating an org-level variable
     */
    201: unknown;
    /**
     * response when creating an org-level variable
     */
    204: unknown;
};

export type UpdateOrgVariableData = {
    body?: UpdateVariableOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/orgs/{org}/actions/variables/{variablename}';
};

export type UpdateOrgVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UpdateOrgVariableResponses = {
    /**
     * response when updating an org-level variable
     */
    201: unknown;
    /**
     * response when updating an org-level variable
     */
    204: unknown;
};

export type OrgListActivityFeedsData = {
    body?: never;
    path: {
        /**
         * name of the org
         */
        org: string;
    };
    query?: {
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/activities/feeds';
};

export type OrgListActivityFeedsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type OrgListActivityFeedsResponse = OrgListActivityFeedsResponses[keyof OrgListActivityFeedsResponses];

export type OrgDeleteAvatarData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/avatar';
};

export type OrgDeleteAvatarErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgDeleteAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgUpdateAvatarData = {
    body?: UpdateUserAvatarOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/avatar';
};

export type OrgUpdateAvatarErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgUpdateAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrganizationListBlocksData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/blocks';
};

export type OrganizationListBlocksResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type OrganizationListBlocksResponse = OrganizationListBlocksResponses[keyof OrganizationListBlocksResponses];

export type OrganizationUnblockUserData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * user to unblock
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/blocks/{username}';
};

export type OrganizationUnblockUserErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type OrganizationUnblockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrganizationCheckUserBlockData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * user to check
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/blocks/{username}';
};

export type OrganizationCheckUserBlockErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrganizationCheckUserBlockResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrganizationBlockUserData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * user to block
         */
        username: string;
    };
    query?: {
        /**
         * optional note for the block
         */
        note?: string;
    };
    url: '/orgs/{org}/blocks/{username}';
};

export type OrganizationBlockUserErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type OrganizationBlockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListHooksData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/hooks';
};

export type OrgListHooksErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type OrgListHooksResponse = OrgListHooksResponses[keyof OrgListHooksResponses];

export type OrgCreateHookData = {
    body: CreateHookOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/hooks';
};

export type OrgCreateHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type OrgCreateHookResponse = OrgCreateHookResponses[keyof OrgCreateHookResponses];

export type OrgDeleteHookData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/hooks/{id}';
};

export type OrgDeleteHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgGetHookData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/hooks/{id}';
};

export type OrgGetHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type OrgGetHookResponse = OrgGetHookResponses[keyof OrgGetHookResponses];

export type OrgEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the hook to update
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/hooks/{id}';
};

export type OrgEditHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type OrgEditHookResponse = OrgEditHookResponses[keyof OrgEditHookResponses];

export type OrgListLabelsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/labels';
};

export type OrgListLabelsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type OrgListLabelsResponse = OrgListLabelsResponses[keyof OrgListLabelsResponses];

export type OrgCreateLabelData = {
    body?: CreateLabelOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/labels';
};

export type OrgCreateLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type OrgCreateLabelResponses = {
    /**
     * Label
     */
    201: Label;
};

export type OrgCreateLabelResponse = OrgCreateLabelResponses[keyof OrgCreateLabelResponses];

export type OrgDeleteLabelData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the label to delete
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/labels/{id}';
};

export type OrgDeleteLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgDeleteLabelResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgGetLabelData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the label to get
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/labels/{id}';
};

export type OrgGetLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgGetLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type OrgGetLabelResponse = OrgGetLabelResponses[keyof OrgGetLabelResponses];

export type OrgEditLabelData = {
    body?: EditLabelOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * id of the label to edit
         */
        id: number;
    };
    query?: never;
    url: '/orgs/{org}/labels/{id}';
};

export type OrgEditLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type OrgEditLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type OrgEditLabelResponse = OrgEditLabelResponses[keyof OrgEditLabelResponses];

export type OrgListMembersData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/members';
};

export type OrgListMembersErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListMembersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type OrgListMembersResponse = OrgListMembersResponses[keyof OrgListMembersResponses];

export type OrgDeleteMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/members/{username}';
};

export type OrgDeleteMemberErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgDeleteMemberResponses = {
    /**
     * member removed
     */
    204: unknown;
};

export type OrgIsMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/members/{username}';
};

export type OrgIsMemberErrors = {
    /**
     * user is not a member
     */
    404: unknown;
};

export type OrgIsMemberResponses = {
    /**
     * user is a member
     */
    204: unknown;
};

export type OrgListPublicMembersData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/public_members';
};

export type OrgListPublicMembersErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListPublicMembersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type OrgListPublicMembersResponse = OrgListPublicMembersResponses[keyof OrgListPublicMembersResponses];

export type OrgConcealMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/public_members/{username}';
};

export type OrgConcealMemberErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgConcealMemberResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgIsPublicMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/public_members/{username}';
};

export type OrgIsPublicMemberErrors = {
    /**
     * user is not a public member
     */
    404: unknown;
};

export type OrgIsPublicMemberResponses = {
    /**
     * user is a public member
     */
    204: unknown;
};

export type OrgPublicizeMemberData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
        /**
         * username of the user
         */
        username: string;
    };
    query?: never;
    url: '/orgs/{org}/public_members/{username}';
};

export type OrgPublicizeMemberErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgPublicizeMemberResponses = {
    /**
     * membership publicized
     */
    204: unknown;
};

export type RenameOrgData = {
    body: RenameOrgOption;
    path: {
        /**
         * existing org name
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/rename';
};

export type RenameOrgErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RenameOrgResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListReposData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/repos';
};

export type OrgListReposErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type OrgListReposResponse = OrgListReposResponses[keyof OrgListReposResponses];

export type CreateOrgRepoData = {
    body?: CreateRepoOption;
    path: {
        /**
         * name of organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/repos';
};

export type CreateOrgRepoErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type CreateOrgRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type CreateOrgRepoResponse = CreateOrgRepoResponses[keyof CreateOrgRepoResponses];

export type OrgListTeamsData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/teams';
};

export type OrgListTeamsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListTeamsResponses = {
    /**
     * TeamList
     */
    200: Array<Team>;
};

export type OrgListTeamsResponse = OrgListTeamsResponses[keyof OrgListTeamsResponses];

export type OrgCreateTeamData = {
    body?: CreateTeamOption;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/orgs/{org}/teams';
};

export type OrgCreateTeamErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type OrgCreateTeamResponses = {
    /**
     * Team
     */
    201: Team;
};

export type OrgCreateTeamResponse = OrgCreateTeamResponses[keyof OrgCreateTeamResponses];

export type TeamSearchData = {
    body?: never;
    path: {
        /**
         * name of the organization
         */
        org: string;
    };
    query?: {
        /**
         * keywords to search
         */
        q?: string;
        /**
         * include search within team description (defaults to true)
         */
        include_desc?: boolean;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/orgs/{org}/teams/search';
};

export type TeamSearchErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type TeamSearchResponses = {
    /**
     * SearchResults of a successful search
     */
    200: {
        data?: Array<Team>;
        ok?: boolean;
    };
};

export type TeamSearchResponse = TeamSearchResponses[keyof TeamSearchResponses];

export type ListPackagesData = {
    body?: never;
    path: {
        /**
         * owner of the packages
         */
        owner: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * package type filter
         */
        type?: 'alpine' | 'cargo' | 'chef' | 'composer' | 'conan' | 'conda' | 'container' | 'cran' | 'debian' | 'generic' | 'go' | 'helm' | 'maven' | 'npm' | 'nuget' | 'pub' | 'pypi' | 'rpm' | 'rubygems' | 'swift' | 'vagrant';
        /**
         * name filter
         */
        q?: string;
    };
    url: '/packages/{owner}';
};

export type ListPackagesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type ListPackagesResponses = {
    /**
     * PackageList
     */
    200: Array<Package>;
};

export type ListPackagesResponse = ListPackagesResponses[keyof ListPackagesResponses];

export type LinkPackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * name of the repository to link.
         */
        repo_name: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/-/link/{repo_name}';
};

export type LinkPackageErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type LinkPackageResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type UnlinkPackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/-/unlink';
};

export type UnlinkPackageErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UnlinkPackageResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type DeletePackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * version of the package
         */
        version: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/{version}';
};

export type DeletePackageErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeletePackageResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type GetPackageData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * version of the package
         */
        version: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/{version}';
};

export type GetPackageErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetPackageResponses = {
    /**
     * Package
     */
    200: Package;
};

export type GetPackageResponse = GetPackageResponses[keyof GetPackageResponses];

export type ListPackageFilesData = {
    body?: never;
    path: {
        /**
         * owner of the package
         */
        owner: string;
        /**
         * type of the package
         */
        type: string;
        /**
         * name of the package
         */
        name: string;
        /**
         * version of the package
         */
        version: string;
    };
    query?: never;
    url: '/packages/{owner}/{type}/{name}/{version}/files';
};

export type ListPackageFilesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type ListPackageFilesResponses = {
    /**
     * PackageFileList
     */
    200: Array<PackageFile>;
};

export type ListPackageFilesResponse = ListPackageFilesResponses[keyof ListPackageFilesResponses];

export type IssueSearchIssuesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * State of the issue
         */
        state?: 'open' | 'closed' | 'all';
        /**
         * Comma-separated list of label names. Fetch only issues that have any of these labels. Non existent labels are discarded.
         */
        labels?: string;
        /**
         * Comma-separated list of milestone names. Fetch only issues that have any of these milestones. Non existent milestones are discarded.
         */
        milestones?: string;
        /**
         * Search string
         */
        q?: string;
        /**
         * Repository ID to prioritize in the results
         */
        priority_repo_id?: number;
        /**
         * Filter by issue type
         */
        type?: 'issues' | 'pulls';
        /**
         * Only show issues updated after the given time (RFC 3339 format)
         */
        since?: string;
        /**
         * Only show issues updated before the given time (RFC 3339 format)
         */
        before?: string;
        /**
         * Filter issues or pulls assigned to the authenticated user
         */
        assigned?: boolean;
        /**
         * Filter issues or pulls created by the authenticated user
         */
        created?: boolean;
        /**
         * Filter issues or pulls mentioning the authenticated user
         */
        mentioned?: boolean;
        /**
         * Filter pull requests where the authenticated user's review was requested
         */
        review_requested?: boolean;
        /**
         * Filter pull requests reviewed by the authenticated user
         */
        reviewed?: boolean;
        /**
         * Filter by repository owner
         */
        owner?: string;
        /**
         * Filter by team (requires organization owner parameter)
         */
        team?: string;
        /**
         * Page number of results to return (1-based)
         */
        page?: number;
        /**
         * Number of items per page
         */
        limit?: number;
    };
    url: '/repos/issues/search';
};

export type IssueSearchIssuesErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type IssueSearchIssuesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueSearchIssuesResponse = IssueSearchIssuesResponses[keyof IssueSearchIssuesResponses];

export type RepoMigrateData = {
    body?: MigrateRepoOptions;
    path?: never;
    query?: never;
    url: '/repos/migrate';
};

export type RepoMigrateErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoMigrateResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type RepoMigrateResponse = RepoMigrateResponses[keyof RepoMigrateResponses];

export type RepoSearchData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * keyword
         */
        q?: string;
        /**
         * Limit search to repositories with keyword as topic
         */
        topic?: boolean;
        /**
         * include search of keyword within repository description
         */
        includeDesc?: boolean;
        /**
         * search only for repos that the user with the given id owns or contributes to
         */
        uid?: number;
        /**
         * repo owner to prioritize in the results
         */
        priority_owner_id?: number;
        /**
         * search only for repos that belong to the given team id
         */
        team_id?: number;
        /**
         * search only for repos that the user with the given id has starred
         */
        starredBy?: number;
        /**
         * include private repositories this user has access to (defaults to true)
         */
        private?: boolean;
        /**
         * show only pubic, private or all repositories (defaults to all)
         */
        is_private?: boolean;
        /**
         * include template repositories this user has access to (defaults to true)
         */
        template?: boolean;
        /**
         * show only archived, non-archived or all repositories (defaults to all)
         */
        archived?: boolean;
        /**
         * type of repository to search for. Supported values are "fork", "source", "mirror" and "collaborative"
         */
        mode?: string;
        /**
         * if `uid` is given, search only for repos that the user owns
         */
        exclusive?: boolean;
        /**
         * sort repos by attribute. Supported values are "alpha", "created", "updated", "size", "git_size", "lfs_size", "stars", "forks" and "id". Default is "alpha"
         */
        sort?: string;
        /**
         * sort order, either "asc" (ascending) or "desc" (descending). Default is "asc", ignored if "sort" is not specified.
         */
        order?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/search';
};

export type RepoSearchErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoSearchResponses = {
    /**
     * SearchResults
     */
    200: SearchResults;
};

export type RepoSearchResponse = RepoSearchResponses[keyof RepoSearchResponses];

export type RepoDeleteData = {
    body?: never;
    path: {
        /**
         * owner of the repo to delete
         */
        owner: string;
        /**
         * name of the repo to delete
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}';
};

export type RepoDeleteErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}';
};

export type RepoGetErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RepoGetResponse = RepoGetResponses[keyof RepoGetResponses];

export type RepoEditData = {
    /**
     * Properties of a repo that you can edit
     */
    body?: EditRepoOption;
    path: {
        /**
         * owner of the repo to edit
         */
        owner: string;
        /**
         * name of the repo to edit
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}';
};

export type RepoEditErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoEditResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RepoEditResponse = RepoEditResponses[keyof RepoEditResponses];

export type GetArtifactsData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
    };
    query?: {
        /**
         * name of the artifact
         */
        name?: string;
    };
    url: '/repos/{owner}/{repo}/actions/artifacts';
};

export type GetArtifactsErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetArtifactsResponses = {
    /**
     * ArtifactsList
     */
    200: ActionArtifactsResponse;
};

export type GetArtifactsResponse = GetArtifactsResponses[keyof GetArtifactsResponses];

export type DeleteArtifactData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * id of the artifact
         */
        artifact_id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}';
};

export type DeleteArtifactErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeleteArtifactResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type GetArtifactData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * id of the artifact
         */
        artifact_id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}';
};

export type GetArtifactErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetArtifactResponses = {
    /**
     * Artifact
     */
    200: ActionArtifact;
};

export type GetArtifactResponse = GetArtifactResponses[keyof GetArtifactResponses];

export type DownloadArtifactData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * id of the artifact
         */
        artifact_id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/artifacts/{artifact_id}/zip';
};

export type DownloadArtifactErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetRunnerRegistrationTokenData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/runners/registration-token';
};

export type RepoGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is response related to registration token
     */
    200: unknown;
};

export type GetArtifactsOfRunData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * runid of the workflow run
         */
        run: number;
    };
    query?: {
        /**
         * name of the artifact
         */
        name?: string;
    };
    url: '/repos/{owner}/{repo}/actions/runs/{run}/artifacts';
};

export type GetArtifactsOfRunErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetArtifactsOfRunResponses = {
    /**
     * ArtifactsList
     */
    200: ActionArtifactsResponse;
};

export type GetArtifactsOfRunResponse = GetArtifactsOfRunResponses[keyof GetArtifactsOfRunResponses];

export type RepoListActionsSecretsData = {
    body?: never;
    path: {
        /**
         * owner of the repository
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/actions/secrets';
};

export type RepoListActionsSecretsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListActionsSecretsResponses = {
    /**
     * SecretList
     */
    200: Array<Secret>;
};

export type RepoListActionsSecretsResponse = RepoListActionsSecretsResponses[keyof RepoListActionsSecretsResponses];

export type DeleteRepoSecretData = {
    body?: never;
    path: {
        /**
         * owner of the repository
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/secrets/{secretname}';
};

export type DeleteRepoSecretErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeleteRepoSecretResponses = {
    /**
     * delete one secret of the organization
     */
    204: unknown;
};

export type UpdateRepoSecretData = {
    body?: CreateOrUpdateSecretOption;
    path: {
        /**
         * owner of the repository
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/secrets/{secretname}';
};

export type UpdateRepoSecretErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UpdateRepoSecretResponses = {
    /**
     * response when creating a secret
     */
    201: unknown;
    /**
     * response when updating a secret
     */
    204: unknown;
};

export type ListActionTasksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results, default maximum page size is 50
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/actions/tasks';
};

export type ListActionTasksErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIConflict is a conflict empty response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type ListActionTasksResponses = {
    /**
     * TasksList
     */
    200: ActionTaskResponse;
};

export type ListActionTasksResponse = ListActionTasksResponses[keyof ListActionTasksResponses];

export type GetRepoVariablesListData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/actions/variables';
};

export type GetRepoVariablesListErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetRepoVariablesListResponses = {
    /**
     * VariableList
     */
    200: Array<ActionVariable>;
};

export type GetRepoVariablesListResponse = GetRepoVariablesListResponses[keyof GetRepoVariablesListResponses];

export type DeleteRepoVariableData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type DeleteRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeleteRepoVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
    /**
     * response when deleting a variable
     */
    201: unknown;
    /**
     * response when deleting a variable
     */
    204: unknown;
};

export type DeleteRepoVariableResponse = DeleteRepoVariableResponses[keyof DeleteRepoVariableResponses];

export type GetRepoVariableData = {
    body?: never;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type GetRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetRepoVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
};

export type GetRepoVariableResponse = GetRepoVariableResponses[keyof GetRepoVariableResponses];

export type CreateRepoVariableData = {
    body?: CreateVariableOption;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type CreateRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type CreateRepoVariableResponses = {
    /**
     * response when creating a repo-level variable
     */
    201: unknown;
    /**
     * response when creating a repo-level variable
     */
    204: unknown;
};

export type UpdateRepoVariableData = {
    body?: UpdateVariableOption;
    path: {
        /**
         * name of the owner
         */
        owner: string;
        /**
         * name of the repository
         */
        repo: string;
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/variables/{variablename}';
};

export type UpdateRepoVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UpdateRepoVariableResponses = {
    /**
     * response when updating a repo-level variable
     */
    201: unknown;
    /**
     * response when updating a repo-level variable
     */
    204: unknown;
};

export type ActionsListRepositoryWorkflowsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/workflows';
};

export type ActionsListRepositoryWorkflowsErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIError is error format response
     */
    500: unknown;
};

export type ActionsListRepositoryWorkflowsResponses = {
    /**
     * ActionWorkflowList
     */
    200: Array<ActionWorkflow>;
};

export type ActionsListRepositoryWorkflowsResponse = ActionsListRepositoryWorkflowsResponses[keyof ActionsListRepositoryWorkflowsResponses];

export type ActionsGetWorkflowData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the workflow
         */
        workflow_id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}';
};

export type ActionsGetWorkflowErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIError is error format response
     */
    500: unknown;
};

export type ActionsGetWorkflowResponses = {
    /**
     * ActionWorkflow
     */
    200: ActionWorkflow;
};

export type ActionsGetWorkflowResponse = ActionsGetWorkflowResponses[keyof ActionsGetWorkflowResponses];

export type ActionsDisableWorkflowData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the workflow
         */
        workflow_id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable';
};

export type ActionsDisableWorkflowErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type ActionsDisableWorkflowResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type ActionsDispatchWorkflowData = {
    body?: CreateActionWorkflowDispatch;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the workflow
         */
        workflow_id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches';
};

export type ActionsDispatchWorkflowErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type ActionsDispatchWorkflowResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type ActionsEnableWorkflowData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the workflow
         */
        workflow_id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable';
};

export type ActionsEnableWorkflowErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIConflict is a conflict empty response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type ActionsEnableWorkflowResponses = {
    /**
     * No Content
     */
    204: unknown;
};

export type RepoListActivityFeedsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/activities/feeds';
};

export type RepoListActivityFeedsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type RepoListActivityFeedsResponse = RepoListActivityFeedsResponses[keyof RepoListActivityFeedsResponses];

export type RepoGetArchiveData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the git reference for download with attached archive format (e.g. master.zip)
         */
        archive: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/archive/{archive}';
};

export type RepoGetArchiveErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetArchiveResponses = {
    /**
     * success
     */
    200: unknown;
};

export type RepoGetAssigneesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/assignees';
};

export type RepoGetAssigneesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetAssigneesResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoGetAssigneesResponse = RepoGetAssigneesResponses[keyof RepoGetAssigneesResponses];

export type RepoDeleteAvatarData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/avatar';
};

export type RepoDeleteAvatarErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoUpdateAvatarData = {
    body?: UpdateRepoAvatarOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/avatar';
};

export type RepoUpdateAvatarErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoUpdateAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoListBranchProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections';
};

export type RepoListBranchProtectionResponses = {
    /**
     * BranchProtectionList
     */
    200: Array<BranchProtection>;
};

export type RepoListBranchProtectionResponse = RepoListBranchProtectionResponses[keyof RepoListBranchProtectionResponses];

export type RepoCreateBranchProtectionData = {
    body?: CreateBranchProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections';
};

export type RepoCreateBranchProtectionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCreateBranchProtectionResponses = {
    /**
     * BranchProtection
     */
    201: BranchProtection;
};

export type RepoCreateBranchProtectionResponse = RepoCreateBranchProtectionResponses[keyof RepoCreateBranchProtectionResponses];

export type RepoUpdateBranchProtectionPrioriesData = {
    body?: UpdateBranchProtectionPriories;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections/priority';
};

export type RepoUpdateBranchProtectionPrioriesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoUpdateBranchProtectionPrioriesResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoDeleteBranchProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of protected branch
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections/{name}';
};

export type RepoDeleteBranchProtectionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteBranchProtectionResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetBranchProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of protected branch
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections/{name}';
};

export type RepoGetBranchProtectionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetBranchProtectionResponses = {
    /**
     * BranchProtection
     */
    200: BranchProtection;
};

export type RepoGetBranchProtectionResponse = RepoGetBranchProtectionResponses[keyof RepoGetBranchProtectionResponses];

export type RepoEditBranchProtectionData = {
    body?: EditBranchProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of protected branch
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branch_protections/{name}';
};

export type RepoEditBranchProtectionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoEditBranchProtectionResponses = {
    /**
     * BranchProtection
     */
    200: BranchProtection;
};

export type RepoEditBranchProtectionResponse = RepoEditBranchProtectionResponses[keyof RepoEditBranchProtectionResponses];

export type RepoListBranchesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/branches';
};

export type RepoListBranchesResponses = {
    /**
     * BranchList
     */
    200: Array<Branch>;
};

export type RepoListBranchesResponse = RepoListBranchesResponses[keyof RepoListBranchesResponses];

export type RepoCreateBranchData = {
    body?: CreateBranchRepoOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches';
};

export type RepoCreateBranchErrors = {
    /**
     * The branch is archived or a mirror.
     */
    403: unknown;
    /**
     * The old branch does not exist.
     */
    404: unknown;
    /**
     * The branch with the same name already exists.
     */
    409: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCreateBranchResponses = {
    /**
     * Branch
     */
    201: Branch;
};

export type RepoCreateBranchResponse = RepoCreateBranchResponses[keyof RepoCreateBranchResponses];

export type RepoDeleteBranchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * branch to delete
         */
        branch: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches/{branch}';
};

export type RepoDeleteBranchErrors = {
    /**
     * APIError is error format response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoDeleteBranchResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetBranchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * branch to get
         */
        branch: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches/{branch}';
};

export type RepoGetBranchErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetBranchResponses = {
    /**
     * Branch
     */
    200: Branch;
};

export type RepoGetBranchResponse = RepoGetBranchResponses[keyof RepoGetBranchResponses];

export type RepoUpdateBranchData = {
    body?: UpdateBranchRepoOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the branch
         */
        branch: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/branches/{branch}';
};

export type RepoUpdateBranchErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoUpdateBranchResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoListCollaboratorsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/collaborators';
};

export type RepoListCollaboratorsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListCollaboratorsResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoListCollaboratorsResponse = RepoListCollaboratorsResponses[keyof RepoListCollaboratorsResponses];

export type RepoDeleteCollaboratorData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator to delete
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}';
};

export type RepoDeleteCollaboratorErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoDeleteCollaboratorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoCheckCollaboratorData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}';
};

export type RepoCheckCollaboratorErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoCheckCollaboratorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoAddCollaboratorData = {
    body?: AddCollaboratorOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator to add
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}';
};

export type RepoAddCollaboratorErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoAddCollaboratorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetRepoPermissionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of the collaborator
         */
        collaborator: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/collaborators/{collaborator}/permission';
};

export type RepoGetRepoPermissionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetRepoPermissionsResponses = {
    /**
     * RepoCollaboratorPermission
     */
    200: RepoCollaboratorPermission;
};

export type RepoGetRepoPermissionsResponse = RepoGetRepoPermissionsResponses[keyof RepoGetRepoPermissionsResponses];

export type RepoGetAllCommitsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * SHA or branch to start listing commits from (usually 'master')
         */
        sha?: string;
        /**
         * filepath of a file/dir
         */
        path?: string;
        /**
         * include diff stats for every commit (disable for speedup, default 'true')
         */
        stat?: boolean;
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results (ignored if used with 'path')
         */
        limit?: number;
        /**
         * commits that match the given specifier will not be listed.
         */
        not?: string;
    };
    url: '/repos/{owner}/{repo}/commits';
};

export type RepoGetAllCommitsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * EmptyRepository
     */
    409: ApiError;
};

export type RepoGetAllCommitsError = RepoGetAllCommitsErrors[keyof RepoGetAllCommitsErrors];

export type RepoGetAllCommitsResponses = {
    /**
     * CommitList
     */
    200: Array<Commit>;
};

export type RepoGetAllCommitsResponse = RepoGetAllCommitsResponses[keyof RepoGetAllCommitsResponses];

export type RepoGetCombinedStatusByRefData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of branch/tag/commit
         */
        ref: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/commits/{ref}/status';
};

export type RepoGetCombinedStatusByRefErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetCombinedStatusByRefResponses = {
    /**
     * CombinedStatus
     */
    200: CombinedStatus;
};

export type RepoGetCombinedStatusByRefResponse = RepoGetCombinedStatusByRefResponses[keyof RepoGetCombinedStatusByRefResponses];

export type RepoListStatusesByRefData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of branch/tag/commit
         */
        ref: string;
    };
    query?: {
        /**
         * type of sort
         */
        sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex';
        /**
         * type of state
         */
        state?: 'pending' | 'success' | 'error' | 'failure' | 'warning';
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/commits/{ref}/statuses';
};

export type RepoListStatusesByRefErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListStatusesByRefResponses = {
    /**
     * CommitStatusList
     */
    200: Array<CommitStatus>;
};

export type RepoListStatusesByRefResponse = RepoListStatusesByRefResponses[keyof RepoListStatusesByRefResponses];

export type RepoGetCommitPullRequestData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * SHA of the commit to get
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/commits/{sha}/pull';
};

export type RepoGetCommitPullRequestErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetCommitPullRequestResponses = {
    /**
     * PullRequest
     */
    200: PullRequest;
};

export type RepoGetCommitPullRequestResponse = RepoGetCommitPullRequestResponses[keyof RepoGetCommitPullRequestResponses];

export type RepoCompareDiffData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * compare two branches or commits
         */
        basehead: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/compare/{basehead}';
};

export type RepoCompareDiffErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoCompareDiffResponses = {
    200: Compare;
};

export type RepoCompareDiffResponse = RepoCompareDiffResponses[keyof RepoCompareDiffResponses];

export type RepoGetContentsListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/contents';
};

export type RepoGetContentsListErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetContentsListResponses = {
    /**
     * ContentsListResponse
     */
    200: Array<ContentsResponse>;
};

export type RepoGetContentsListResponse = RepoGetContentsListResponses[keyof RepoGetContentsListResponses];

export type RepoChangeFilesData = {
    body: ChangeFilesOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents';
};

export type RepoChangeFilesErrors = {
    /**
     * APIError is error format response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoChangeFilesResponses = {
    /**
     * FilesResponse
     */
    201: FilesResponse;
};

export type RepoChangeFilesResponse = RepoChangeFilesResponses[keyof RepoChangeFilesResponses];

export type RepoDeleteFileData = {
    body: DeleteFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to delete
         */
        filepath: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoDeleteFileErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIError is error format response
     */
    403: unknown;
    /**
     * APIError is error format response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoDeleteFileResponses = {
    /**
     * FileDeleteResponse
     */
    200: FileDeleteResponse;
};

export type RepoDeleteFileResponse = RepoDeleteFileResponses[keyof RepoDeleteFileResponses];

export type RepoGetContentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the dir, file, symlink or submodule in the repo
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoGetContentsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetContentsResponses = {
    /**
     * ContentsResponse
     */
    200: ContentsResponse;
};

export type RepoGetContentsResponse = RepoGetContentsResponses[keyof RepoGetContentsResponses];

export type RepoCreateFileData = {
    body: CreateFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to create
         */
        filepath: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoCreateFileErrors = {
    /**
     * APIError is error format response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCreateFileResponses = {
    /**
     * FileResponse
     */
    201: FileResponse;
};

export type RepoCreateFileResponse = RepoCreateFileResponses[keyof RepoCreateFileResponses];

export type RepoUpdateFileData = {
    body: UpdateFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to update
         */
        filepath: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/contents/{filepath}';
};

export type RepoUpdateFileErrors = {
    /**
     * APIError is error format response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoUpdateFileResponses = {
    /**
     * FileResponse
     */
    200: FileResponse;
};

export type RepoUpdateFileResponse = RepoUpdateFileResponses[keyof RepoUpdateFileResponses];

export type RepoApplyDiffPatchData = {
    body: UpdateFileOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/diffpatch';
};

export type RepoApplyDiffPatchErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoApplyDiffPatchResponses = {
    /**
     * FileResponse
     */
    200: FileResponse;
};

export type RepoApplyDiffPatchResponse = RepoApplyDiffPatchResponses[keyof RepoApplyDiffPatchResponses];

export type RepoGetEditorConfigData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * filepath of file to get
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch (usually master)
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/editorconfig/{filepath}';
};

export type RepoGetEditorConfigErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetEditorConfigResponses = {
    /**
     * success
     */
    200: unknown;
};

export type ListForksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/forks';
};

export type ListForksErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type ListForksResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type ListForksResponse = ListForksResponses[keyof ListForksResponses];

export type CreateForkData = {
    body?: CreateForkOption;
    path: {
        /**
         * owner of the repo to fork
         */
        owner: string;
        /**
         * name of the repo to fork
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/forks';
};

export type CreateForkErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type CreateForkResponses = {
    /**
     * Repository
     */
    202: Repository;
};

export type CreateForkResponse = CreateForkResponses[keyof CreateForkResponses];

export type GetBlobData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/blobs/{sha}';
};

export type GetBlobErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetBlobResponses = {
    /**
     * GitBlobResponse
     */
    200: GitBlobResponse;
};

export type GetBlobResponse = GetBlobResponses[keyof GetBlobResponses];

export type RepoGetSingleCommitData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * a git ref or commit sha
         */
        sha: string;
    };
    query?: {
        /**
         * include diff stats for every commit (disable for speedup, default 'true')
         */
        stat?: boolean;
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
    };
    url: '/repos/{owner}/{repo}/git/commits/{sha}';
};

export type RepoGetSingleCommitErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoGetSingleCommitResponses = {
    /**
     * Commit
     */
    200: Commit;
};

export type RepoGetSingleCommitResponse = RepoGetSingleCommitResponses[keyof RepoGetSingleCommitResponses];

export type RepoDownloadCommitDiffOrPatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * SHA of the commit to get
         */
        sha: string;
        /**
         * whether the output is diff or patch
         */
        diffType: 'diff' | 'patch';
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/commits/{sha}.{diffType}';
};

export type RepoDownloadCommitDiffOrPatchErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDownloadCommitDiffOrPatchResponses = {
    /**
     * APIString is a string response
     */
    200: string;
};

export type RepoDownloadCommitDiffOrPatchResponse = RepoDownloadCommitDiffOrPatchResponses[keyof RepoDownloadCommitDiffOrPatchResponses];

export type RepoGetNoteData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * a git ref or commit sha
         */
        sha: string;
    };
    query?: {
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
    };
    url: '/repos/{owner}/{repo}/git/notes/{sha}';
};

export type RepoGetNoteErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoGetNoteResponses = {
    /**
     * Note
     */
    200: Note;
};

export type RepoGetNoteResponse = RepoGetNoteResponses[keyof RepoGetNoteResponses];

export type RepoListAllGitRefsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/refs';
};

export type RepoListAllGitRefsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListAllGitRefsResponses = {
    /**
     * ReferenceList
     */
    200: Array<Reference>;
};

export type RepoListAllGitRefsResponse = RepoListAllGitRefsResponses[keyof RepoListAllGitRefsResponses];

export type RepoListGitRefsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * part or full name of the ref
         */
        ref: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/refs/{ref}';
};

export type RepoListGitRefsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListGitRefsResponses = {
    /**
     * ReferenceList
     */
    200: Array<Reference>;
};

export type RepoListGitRefsResponse = RepoListGitRefsResponses[keyof RepoListGitRefsResponses];

export type GetAnnotatedTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the tag. The Git tags API only supports annotated tag objects, not lightweight tags.
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/git/tags/{sha}';
};

export type GetAnnotatedTagErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetAnnotatedTagResponses = {
    /**
     * AnnotatedTag
     */
    200: AnnotatedTag;
};

export type GetAnnotatedTagResponse = GetAnnotatedTagResponses[keyof GetAnnotatedTagResponses];

export type GetTreeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: {
        /**
         * show all directories and files
         */
        recursive?: boolean;
        /**
         * page number; the 'truncated' field in the response will be true if there are still more items after this page, false if the last page
         */
        page?: number;
        /**
         * number of items per page
         */
        per_page?: number;
    };
    url: '/repos/{owner}/{repo}/git/trees/{sha}';
};

export type GetTreeErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetTreeResponses = {
    /**
     * GitTreeResponse
     */
    200: GitTreeResponse;
};

export type GetTreeResponse = GetTreeResponses[keyof GetTreeResponses];

export type RepoListHooksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/hooks';
};

export type RepoListHooksErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type RepoListHooksResponse = RepoListHooksResponses[keyof RepoListHooksResponses];

export type RepoCreateHookData = {
    body?: CreateHookOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks';
};

export type RepoCreateHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type RepoCreateHookResponse = RepoCreateHookResponses[keyof RepoCreateHookResponses];

export type RepoListGitHooksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git';
};

export type RepoListGitHooksErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListGitHooksResponses = {
    /**
     * GitHookList
     */
    200: Array<GitHook>;
};

export type RepoListGitHooksResponse = RepoListGitHooksResponses[keyof RepoListGitHooksResponses];

export type RepoDeleteGitHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git/{id}';
};

export type RepoDeleteGitHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteGitHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetGitHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git/{id}';
};

export type RepoGetGitHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetGitHookResponses = {
    /**
     * GitHook
     */
    200: GitHook;
};

export type RepoGetGitHookResponse = RepoGetGitHookResponses[keyof RepoGetGitHookResponses];

export type RepoEditGitHookData = {
    body?: EditGitHookOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/git/{id}';
};

export type RepoEditGitHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoEditGitHookResponses = {
    /**
     * GitHook
     */
    200: GitHook;
};

export type RepoEditGitHookResponse = RepoEditGitHookResponses[keyof RepoEditGitHookResponses];

export type RepoDeleteHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/{id}';
};

export type RepoDeleteHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/{id}';
};

export type RepoGetHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type RepoGetHookResponse = RepoGetHookResponses[keyof RepoGetHookResponses];

export type RepoEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the hook
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/hooks/{id}';
};

export type RepoEditHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type RepoEditHookResponse = RepoEditHookResponses[keyof RepoEditHookResponses];

export type RepoTestHookData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the hook to test
         */
        id: number;
    };
    query?: {
        /**
         * The name of the commit/branch/tag, indicates which commit will be loaded to the webhook payload.
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/hooks/{id}/tests';
};

export type RepoTestHookErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoTestHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetIssueConfigData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issue_config';
};

export type RepoGetIssueConfigErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetIssueConfigResponses = {
    /**
     * RepoIssueConfig
     */
    200: IssueConfig;
};

export type RepoGetIssueConfigResponse = RepoGetIssueConfigResponses[keyof RepoGetIssueConfigResponses];

export type RepoValidateIssueConfigData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issue_config/validate';
};

export type RepoValidateIssueConfigErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoValidateIssueConfigResponses = {
    /**
     * RepoIssueConfigValidation
     */
    200: IssueConfigValidation;
};

export type RepoValidateIssueConfigResponse = RepoValidateIssueConfigResponses[keyof RepoValidateIssueConfigResponses];

export type RepoGetIssueTemplatesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issue_templates';
};

export type RepoGetIssueTemplatesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetIssueTemplatesResponses = {
    /**
     * IssueTemplates
     */
    200: Array<IssueTemplate>;
};

export type RepoGetIssueTemplatesResponse = RepoGetIssueTemplatesResponses[keyof RepoGetIssueTemplatesResponses];

export type IssueListIssuesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * whether issue is open or closed
         */
        state?: 'closed' | 'open' | 'all';
        /**
         * comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         */
        labels?: string;
        /**
         * search string
         */
        q?: string;
        /**
         * filter by type (issues / pulls) if set
         */
        type?: 'issues' | 'pulls';
        /**
         * comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         */
        milestones?: string;
        /**
         * Only show items updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show items updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * Only show items which were created by the given user
         */
        created_by?: string;
        /**
         * Only show items for which the given user is assigned
         */
        assigned_by?: string;
        /**
         * Only show items in which the given user was mentioned
         */
        mentioned_by?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues';
};

export type IssueListIssuesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueListIssuesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueListIssuesResponse = IssueListIssuesResponses[keyof IssueListIssuesResponses];

export type IssueCreateIssueData = {
    body?: CreateIssueOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues';
};

export type IssueCreateIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    412: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueCreateIssueResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueCreateIssueResponse = IssueCreateIssueResponses[keyof IssueCreateIssueResponses];

export type IssueGetRepoCommentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * if provided, only comments updated since the provided time are returned.
         */
        since?: string;
        /**
         * if provided, only comments updated before the provided time are returned.
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/comments';
};

export type IssueGetRepoCommentsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetRepoCommentsResponses = {
    /**
     * CommentList
     */
    200: Array<Comment>;
};

export type IssueGetRepoCommentsResponse = IssueGetRepoCommentsResponses[keyof IssueGetRepoCommentsResponses];

export type IssueDeleteCommentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of comment to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}';
};

export type IssueDeleteCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteCommentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetCommentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}';
};

export type IssueGetCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetCommentResponses = {
    /**
     * Comment
     */
    200: Comment;
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetCommentResponse = IssueGetCommentResponses[keyof IssueGetCommentResponses];

export type IssueEditCommentData = {
    body?: EditIssueCommentOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}';
};

export type IssueEditCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueEditCommentResponses = {
    /**
     * Comment
     */
    200: Comment;
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueEditCommentResponse = IssueEditCommentResponses[keyof IssueEditCommentResponses];

export type IssueListIssueCommentAttachmentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets';
};

export type IssueListIssueCommentAttachmentsErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
};

export type IssueListIssueCommentAttachmentsResponses = {
    /**
     * AttachmentList
     */
    200: Array<Attachment>;
};

export type IssueListIssueCommentAttachmentsResponse = IssueListIssueCommentAttachmentsResponses[keyof IssueListIssueCommentAttachmentsResponses];

export type IssueCreateIssueCommentAttachmentData = {
    body: {
        /**
         * attachment to upload
         */
        attachment: Blob | File;
    };
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
    };
    query?: {
        /**
         * name of the attachment
         */
        name?: string;
    };
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets';
};

export type IssueCreateIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APIError is error format response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueCreateIssueCommentAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueCreateIssueCommentAttachmentResponse = IssueCreateIssueCommentAttachmentResponses[keyof IssueCreateIssueCommentAttachmentResponses];

export type IssueDeleteIssueCommentAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
        /**
         * id of the attachment to delete
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}';
};

export type IssueDeleteIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueDeleteIssueCommentAttachmentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetIssueCommentAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
        /**
         * id of the attachment to get
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}';
};

export type IssueGetIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
};

export type IssueGetIssueCommentAttachmentResponses = {
    /**
     * Attachment
     */
    200: Attachment;
};

export type IssueGetIssueCommentAttachmentResponse = IssueGetIssueCommentAttachmentResponses[keyof IssueGetIssueCommentAttachmentResponses];

export type IssueEditIssueCommentAttachmentData = {
    body?: EditAttachmentOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment
         */
        id: number;
        /**
         * id of the attachment to edit
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}';
};

export type IssueEditIssueCommentAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueEditIssueCommentAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueEditIssueCommentAttachmentResponse = IssueEditIssueCommentAttachmentResponses[keyof IssueEditIssueCommentAttachmentResponses];

export type IssueDeleteCommentReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
};

export type IssueDeleteCommentReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteCommentReactionResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type IssueGetCommentReactionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
};

export type IssueGetCommentReactionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetCommentReactionsResponses = {
    /**
     * ReactionList
     */
    200: Array<Reaction>;
};

export type IssueGetCommentReactionsResponse = IssueGetCommentReactionsResponses[keyof IssueGetCommentReactionsResponses];

export type IssuePostCommentReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/comments/{id}/reactions';
};

export type IssuePostCommentReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssuePostCommentReactionResponses = {
    /**
     * Reaction
     */
    200: Reaction;
    /**
     * Reaction
     */
    201: Reaction;
};

export type IssuePostCommentReactionResponse = IssuePostCommentReactionResponses[keyof IssuePostCommentReactionResponses];

export type RepoListPinnedIssuesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/pinned';
};

export type RepoListPinnedIssuesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListPinnedIssuesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type RepoListPinnedIssuesResponse = RepoListPinnedIssuesResponses[keyof RepoListPinnedIssuesResponses];

export type IssueDeleteData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue to delete
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}';
};

export type IssueDeleteErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetIssueData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to get
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}';
};

export type IssueGetIssueErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetIssueResponses = {
    /**
     * Issue
     */
    200: Issue;
};

export type IssueGetIssueResponse = IssueGetIssueResponses[keyof IssueGetIssueResponses];

export type IssueEditIssueData = {
    body?: EditIssueOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to edit
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}';
};

export type IssueEditIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    412: unknown;
};

export type IssueEditIssueResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueEditIssueResponse = IssueEditIssueResponses[keyof IssueEditIssueResponses];

export type IssueListIssueAttachmentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets';
};

export type IssueListIssueAttachmentsErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
};

export type IssueListIssueAttachmentsResponses = {
    /**
     * AttachmentList
     */
    200: Array<Attachment>;
};

export type IssueListIssueAttachmentsResponse = IssueListIssueAttachmentsResponses[keyof IssueListIssueAttachmentsResponses];

export type IssueCreateIssueAttachmentData = {
    body: {
        /**
         * attachment to upload
         */
        attachment: Blob | File;
    };
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * name of the attachment
         */
        name?: string;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/assets';
};

export type IssueCreateIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIError is error format response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueCreateIssueAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueCreateIssueAttachmentResponse = IssueCreateIssueAttachmentResponses[keyof IssueCreateIssueAttachmentResponses];

export type IssueDeleteIssueAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the attachment to delete
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}';
};

export type IssueDeleteIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueDeleteIssueAttachmentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetIssueAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the attachment to get
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}';
};

export type IssueGetIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
};

export type IssueGetIssueAttachmentResponses = {
    /**
     * Attachment
     */
    200: Attachment;
};

export type IssueGetIssueAttachmentResponse = IssueGetIssueAttachmentResponses[keyof IssueGetIssueAttachmentResponses];

export type IssueEditIssueAttachmentData = {
    body?: EditAttachmentOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the attachment to edit
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}';
};

export type IssueEditIssueAttachmentErrors = {
    /**
     * APIError is error format response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueEditIssueAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type IssueEditIssueAttachmentResponse = IssueEditIssueAttachmentResponses[keyof IssueEditIssueAttachmentResponses];

export type IssueRemoveIssueBlockingData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/blocks';
};

export type IssueRemoveIssueBlockingErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueRemoveIssueBlockingResponses = {
    /**
     * Issue
     */
    200: Issue;
};

export type IssueRemoveIssueBlockingResponse = IssueRemoveIssueBlockingResponses[keyof IssueRemoveIssueBlockingResponses];

export type IssueListBlocksData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/blocks';
};

export type IssueListBlocksErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueListBlocksResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueListBlocksResponse = IssueListBlocksResponses[keyof IssueListBlocksResponses];

export type IssueCreateIssueBlockingData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/blocks';
};

export type IssueCreateIssueBlockingErrors = {
    /**
     * the issue does not exist
     */
    404: unknown;
};

export type IssueCreateIssueBlockingResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueCreateIssueBlockingResponse = IssueCreateIssueBlockingResponses[keyof IssueCreateIssueBlockingResponses];

export type IssueGetCommentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * if provided, only comments updated since the specified time are returned.
         */
        since?: string;
        /**
         * if provided, only comments updated before the provided time are returned.
         */
        before?: string;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/comments';
};

export type IssueGetCommentsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetCommentsResponses = {
    /**
     * CommentList
     */
    200: Array<Comment>;
};

export type IssueGetCommentsResponse = IssueGetCommentsResponses[keyof IssueGetCommentsResponses];

export type IssueCreateCommentData = {
    body?: CreateIssueCommentOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/comments';
};

export type IssueCreateCommentErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueCreateCommentResponses = {
    /**
     * Comment
     */
    201: Comment;
};

export type IssueCreateCommentResponse = IssueCreateCommentResponses[keyof IssueCreateCommentResponses];

export type IssueDeleteCommentDeprecatedData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * this parameter is ignored
         */
        index: number;
        /**
         * id of comment to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/comments/{id}';
};

export type IssueDeleteCommentDeprecatedErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteCommentDeprecatedResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueEditCommentDeprecatedData = {
    body?: EditIssueCommentOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * this parameter is ignored
         */
        index: number;
        /**
         * id of the comment to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/comments/{id}';
};

export type IssueEditCommentDeprecatedErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueEditCommentDeprecatedResponses = {
    /**
     * Comment
     */
    200: Comment;
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueEditCommentDeprecatedResponse = IssueEditCommentDeprecatedResponses[keyof IssueEditCommentDeprecatedResponses];

export type IssueEditIssueDeadlineData = {
    body?: EditDeadlineOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to create or update a deadline on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/deadline';
};

export type IssueEditIssueDeadlineErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueEditIssueDeadlineResponses = {
    /**
     * IssueDeadline
     */
    201: IssueDeadline;
};

export type IssueEditIssueDeadlineResponse = IssueEditIssueDeadlineResponses[keyof IssueEditIssueDeadlineResponses];

export type IssueRemoveIssueDependenciesData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/dependencies';
};

export type IssueRemoveIssueDependenciesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueRemoveIssueDependenciesResponses = {
    /**
     * Issue
     */
    200: Issue;
};

export type IssueRemoveIssueDependenciesResponse = IssueRemoveIssueDependenciesResponses[keyof IssueRemoveIssueDependenciesResponses];

export type IssueListIssueDependenciesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/dependencies';
};

export type IssueListIssueDependenciesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueListIssueDependenciesResponses = {
    /**
     * IssueList
     */
    200: Array<Issue>;
};

export type IssueListIssueDependenciesResponse = IssueListIssueDependenciesResponses[keyof IssueListIssueDependenciesResponses];

export type IssueCreateIssueDependenciesData = {
    body?: IssueMeta;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/dependencies';
};

export type IssueCreateIssueDependenciesErrors = {
    /**
     * the issue does not exist
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type IssueCreateIssueDependenciesResponses = {
    /**
     * Issue
     */
    201: Issue;
};

export type IssueCreateIssueDependenciesResponse = IssueCreateIssueDependenciesResponses[keyof IssueCreateIssueDependenciesResponses];

export type IssueClearLabelsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueClearLabelsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueClearLabelsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetLabelsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueGetLabelsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueGetLabelsResponse = IssueGetLabelsResponses[keyof IssueGetLabelsResponses];

export type IssueAddLabelData = {
    body?: IssueLabelsOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueAddLabelErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueAddLabelResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueAddLabelResponse = IssueAddLabelResponses[keyof IssueAddLabelResponses];

export type IssueReplaceLabelsData = {
    body?: IssueLabelsOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels';
};

export type IssueReplaceLabelsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueReplaceLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueReplaceLabelsResponse = IssueReplaceLabelsResponses[keyof IssueReplaceLabelsResponses];

export type IssueRemoveLabelData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of the label to remove
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/labels/{id}';
};

export type IssueRemoveLabelErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type IssueRemoveLabelResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UnpinIssueData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue to unpin
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/pin';
};

export type UnpinIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UnpinIssueResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type PinIssueData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue to pin
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/pin';
};

export type PinIssueErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type PinIssueResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type MoveIssuePinData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of issue
         */
        index: number;
        /**
         * the new position
         */
        position: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/pin/{position}';
};

export type MoveIssuePinErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type MoveIssuePinResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueDeleteIssueReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/reactions';
};

export type IssueDeleteIssueReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteIssueReactionResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type IssueGetIssueReactionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/reactions';
};

export type IssueGetIssueReactionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetIssueReactionsResponses = {
    /**
     * ReactionList
     */
    200: Array<Reaction>;
};

export type IssueGetIssueReactionsResponse = IssueGetIssueReactionsResponses[keyof IssueGetIssueReactionsResponses];

export type IssuePostIssueReactionData = {
    body?: EditReactionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/reactions';
};

export type IssuePostIssueReactionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssuePostIssueReactionResponses = {
    /**
     * Reaction
     */
    200: Reaction;
    /**
     * Reaction
     */
    201: Reaction;
};

export type IssuePostIssueReactionResponse = IssuePostIssueReactionResponses[keyof IssuePostIssueReactionResponses];

export type IssueDeleteStopWatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to stop the stopwatch on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/stopwatch/delete';
};

export type IssueDeleteStopWatchErrors = {
    /**
     * Not repo writer, user does not have rights to toggle stopwatch
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * Cannot cancel a non existent stopwatch
     */
    409: unknown;
};

export type IssueDeleteStopWatchResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueStartStopWatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to create the stopwatch on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/stopwatch/start';
};

export type IssueStartStopWatchErrors = {
    /**
     * Not repo writer, user does not have rights to toggle stopwatch
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * Cannot start a stopwatch again if it already exists
     */
    409: unknown;
};

export type IssueStartStopWatchResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type IssueStopStopWatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to stop the stopwatch on
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/stopwatch/stop';
};

export type IssueStopStopWatchErrors = {
    /**
     * Not repo writer, user does not have rights to toggle stopwatch
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * Cannot stop a non existent stopwatch
     */
    409: unknown;
};

export type IssueStopStopWatchResponses = {
    /**
     * APIEmpty is an empty response
     */
    201: unknown;
};

export type IssueSubscriptionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions';
};

export type IssueSubscriptionsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueSubscriptionsResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type IssueSubscriptionsResponse = IssueSubscriptionsResponses[keyof IssueSubscriptionsResponses];

export type IssueCheckSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions/check';
};

export type IssueCheckSubscriptionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueCheckSubscriptionResponses = {
    /**
     * WatchInfo
     */
    200: WatchInfo;
};

export type IssueCheckSubscriptionResponse = IssueCheckSubscriptionResponses[keyof IssueCheckSubscriptionResponses];

export type IssueDeleteSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * user witch unsubscribe
         */
        user: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}';
};

export type IssueDeleteSubscriptionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteSubscriptionResponses = {
    /**
     * Already unsubscribed
     */
    200: unknown;
    /**
     * Successfully Unsubscribed
     */
    201: unknown;
};

export type IssueAddSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * user to subscribe
         */
        user: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}';
};

export type IssueAddSubscriptionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueAddSubscriptionResponses = {
    /**
     * Already subscribed
     */
    200: unknown;
    /**
     * Successfully Subscribed
     */
    201: unknown;
};

export type IssueGetCommentsAndTimelineData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * if provided, only comments updated since the specified time are returned.
         */
        since?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * if provided, only comments updated before the provided time are returned.
         */
        before?: string;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/timeline';
};

export type IssueGetCommentsAndTimelineErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetCommentsAndTimelineResponses = {
    /**
     * TimelineList
     */
    200: Array<TimelineComment>;
};

export type IssueGetCommentsAndTimelineResponse = IssueGetCommentsAndTimelineResponses[keyof IssueGetCommentsAndTimelineResponses];

export type IssueResetTimeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue to add tracked time to
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/times';
};

export type IssueResetTimeErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueResetTimeResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueTrackedTimesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: {
        /**
         * optional filter by user (available for issue managers)
         */
        user?: string;
        /**
         * Only show times updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show times updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/issues/{index}/times';
};

export type IssueTrackedTimesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type IssueTrackedTimesResponse = IssueTrackedTimesResponses[keyof IssueTrackedTimesResponses];

export type IssueAddTimeData = {
    body?: AddTimeOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/times';
};

export type IssueAddTimeErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueAddTimeResponses = {
    /**
     * TrackedTime
     */
    200: TrackedTime;
};

export type IssueAddTimeResponse = IssueAddTimeResponses[keyof IssueAddTimeResponses];

export type IssueDeleteTimeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the issue
         */
        index: number;
        /**
         * id of time to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/issues/{index}/times/{id}';
};

export type IssueDeleteTimeErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteTimeResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoListKeysData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * the key_id to search for
         */
        key_id?: number;
        /**
         * fingerprint of the key
         */
        fingerprint?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/keys';
};

export type RepoListKeysErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListKeysResponses = {
    /**
     * DeployKeyList
     */
    200: Array<DeployKey>;
};

export type RepoListKeysResponse = RepoListKeysResponses[keyof RepoListKeysResponses];

export type RepoCreateKeyData = {
    body?: CreateKeyOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/keys';
};

export type RepoCreateKeyErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoCreateKeyResponses = {
    /**
     * DeployKey
     */
    201: DeployKey;
};

export type RepoCreateKeyResponse = RepoCreateKeyResponses[keyof RepoCreateKeyResponses];

export type RepoDeleteKeyData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the key to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/keys/{id}';
};

export type RepoDeleteKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetKeyData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the key to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/keys/{id}';
};

export type RepoGetKeyErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetKeyResponses = {
    /**
     * DeployKey
     */
    200: DeployKey;
};

export type RepoGetKeyResponse = RepoGetKeyResponses[keyof RepoGetKeyResponses];

export type IssueListLabelsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/labels';
};

export type IssueListLabelsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueListLabelsResponses = {
    /**
     * LabelList
     */
    200: Array<Label>;
};

export type IssueListLabelsResponse = IssueListLabelsResponses[keyof IssueListLabelsResponses];

export type IssueCreateLabelData = {
    body?: CreateLabelOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels';
};

export type IssueCreateLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type IssueCreateLabelResponses = {
    /**
     * Label
     */
    201: Label;
};

export type IssueCreateLabelResponse = IssueCreateLabelResponses[keyof IssueCreateLabelResponses];

export type IssueDeleteLabelData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the label to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels/{id}';
};

export type IssueDeleteLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteLabelResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetLabelData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the label to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels/{id}';
};

export type IssueGetLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type IssueGetLabelResponse = IssueGetLabelResponses[keyof IssueGetLabelResponses];

export type IssueEditLabelData = {
    body?: EditLabelOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the label to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/labels/{id}';
};

export type IssueEditLabelErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type IssueEditLabelResponses = {
    /**
     * Label
     */
    200: Label;
};

export type IssueEditLabelResponse = IssueEditLabelResponses[keyof IssueEditLabelResponses];

export type RepoGetLanguagesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/languages';
};

export type RepoGetLanguagesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetLanguagesResponses = {
    /**
     * LanguageStatistics
     */
    200: {
        [key: string]: number;
    };
};

export type RepoGetLanguagesResponse = RepoGetLanguagesResponses[keyof RepoGetLanguagesResponses];

export type RepoGetLicensesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/licenses';
};

export type RepoGetLicensesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetLicensesResponses = {
    /**
     * LicensesList
     */
    200: Array<string>;
};

export type RepoGetLicensesResponse = RepoGetLicensesResponses[keyof RepoGetLicensesResponses];

export type RepoGetRawFileOrLfsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to get, it should be "{ref}/{filepath}". If there is no ref could be inferred, it will be treated as the default branch
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/media/{filepath}';
};

export type RepoGetRawFileOrLfsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: Blob | File;
};

export type RepoGetRawFileOrLfsError = RepoGetRawFileOrLfsErrors[keyof RepoGetRawFileOrLfsErrors];

export type RepoGetRawFileOrLfsResponses = {
    /**
     * Returns raw file content.
     */
    200: unknown;
};

export type RepoMergeUpstreamData = {
    body?: MergeUpstreamRequest;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/merge-upstream';
};

export type RepoMergeUpstreamErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoMergeUpstreamResponses = {
    200: MergeUpstreamResponse;
};

export type RepoMergeUpstreamResponse = RepoMergeUpstreamResponses[keyof RepoMergeUpstreamResponses];

export type IssueGetMilestonesListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * Milestone state, Recognized values are open, closed and all. Defaults to "open"
         */
        state?: string;
        /**
         * filter by milestone name
         */
        name?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/milestones';
};

export type IssueGetMilestonesListErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetMilestonesListResponses = {
    /**
     * MilestoneList
     */
    200: Array<Milestone>;
};

export type IssueGetMilestonesListResponse = IssueGetMilestonesListResponses[keyof IssueGetMilestonesListResponses];

export type IssueCreateMilestoneData = {
    body?: CreateMilestoneOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones';
};

export type IssueCreateMilestoneErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueCreateMilestoneResponses = {
    /**
     * Milestone
     */
    201: Milestone;
};

export type IssueCreateMilestoneResponse = IssueCreateMilestoneResponses[keyof IssueCreateMilestoneResponses];

export type IssueDeleteMilestoneData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the milestone to delete, identified by ID and if not available by name
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones/{id}';
};

export type IssueDeleteMilestoneErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueDeleteMilestoneResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type IssueGetMilestoneData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the milestone to get, identified by ID and if not available by name
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones/{id}';
};

export type IssueGetMilestoneErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueGetMilestoneResponses = {
    /**
     * Milestone
     */
    200: Milestone;
};

export type IssueGetMilestoneResponse = IssueGetMilestoneResponses[keyof IssueGetMilestoneResponses];

export type IssueEditMilestoneData = {
    body?: EditMilestoneOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * the milestone to edit, identified by ID and if not available by name
         */
        id: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/milestones/{id}';
};

export type IssueEditMilestoneErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type IssueEditMilestoneResponses = {
    /**
     * Milestone
     */
    200: Milestone;
};

export type IssueEditMilestoneResponse = IssueEditMilestoneResponses[keyof IssueEditMilestoneResponses];

export type RepoMirrorSyncData = {
    body?: never;
    path: {
        /**
         * owner of the repo to sync
         */
        owner: string;
        /**
         * name of the repo to sync
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/mirror-sync';
};

export type RepoMirrorSyncErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoMirrorSyncResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoNewPinAllowedData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/new_pin_allowed';
};

export type RepoNewPinAllowedErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoNewPinAllowedResponses = {
    /**
     * RepoNewIssuePinsAllowed
     */
    200: NewIssuePinsAllowed;
};

export type RepoNewPinAllowedResponse = RepoNewPinAllowedResponses[keyof RepoNewPinAllowedResponses];

export type NotifyGetRepoListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * If true, show notifications marked as read. Default value is false
         */
        all?: boolean;
        /**
         * Show notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread & pinned
         */
        'status-types'?: Array<string>;
        /**
         * filter notifications by subject type
         */
        'subject-type'?: Array<'issue' | 'pull' | 'commit' | 'repository'>;
        /**
         * Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/notifications';
};

export type NotifyGetRepoListResponses = {
    /**
     * NotificationThreadList
     */
    200: Array<NotificationThread>;
};

export type NotifyGetRepoListResponse = NotifyGetRepoListResponses[keyof NotifyGetRepoListResponses];

export type NotifyReadRepoListData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * If true, mark all notifications on this repo. Default value is false
         */
        all?: string;
        /**
         * Mark notifications with the provided status types. Options are: unread, read and/or pinned. Defaults to unread.
         */
        'status-types'?: Array<string>;
        /**
         * Status to mark notifications as. Defaults to read.
         */
        'to-status'?: string;
        /**
         * Describes the last point that notifications were checked. Anything updated since this time will not be updated.
         */
        last_read_at?: string;
    };
    url: '/repos/{owner}/{repo}/notifications';
};

export type NotifyReadRepoListResponses = {
    /**
     * NotificationThreadList
     */
    205: Array<NotificationThread>;
};

export type NotifyReadRepoListResponse = NotifyReadRepoListResponses[keyof NotifyReadRepoListResponses];

export type RepoListPullRequestsData = {
    body?: never;
    path: {
        /**
         * Owner of the repo
         */
        owner: string;
        /**
         * Name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * Filter by target base branch of the pull request
         */
        base_branch?: string;
        /**
         * State of pull request
         */
        state?: 'open' | 'closed' | 'all';
        /**
         * Type of sort
         */
        sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'mostcomment' | 'leastcomment' | 'priority';
        /**
         * ID of the milestone
         */
        milestone?: number;
        /**
         * Label IDs
         */
        labels?: Array<number>;
        /**
         * Filter by pull request author
         */
        poster?: string;
        /**
         * Page number of results to return (1-based)
         */
        page?: number;
        /**
         * Page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/pulls';
};

export type RepoListPullRequestsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    500: unknown;
};

export type RepoListPullRequestsResponses = {
    /**
     * PullRequestList
     */
    200: Array<PullRequest>;
};

export type RepoListPullRequestsResponse = RepoListPullRequestsResponses[keyof RepoListPullRequestsResponses];

export type RepoCreatePullRequestData = {
    body?: CreatePullRequestOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls';
};

export type RepoCreatePullRequestErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCreatePullRequestResponses = {
    /**
     * PullRequest
     */
    201: PullRequest;
};

export type RepoCreatePullRequestResponse = RepoCreatePullRequestResponses[keyof RepoCreatePullRequestResponses];

export type RepoListPinnedPullRequestsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/pinned';
};

export type RepoListPinnedPullRequestsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListPinnedPullRequestsResponses = {
    /**
     * PullRequestList
     */
    200: Array<PullRequest>;
};

export type RepoListPinnedPullRequestsResponse = RepoListPinnedPullRequestsResponses[keyof RepoListPinnedPullRequestsResponses];

export type RepoGetPullRequestByBaseHeadData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * base of the pull request to get
         */
        base: string;
        /**
         * head of the pull request to get
         */
        head: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{base}/{head}';
};

export type RepoGetPullRequestByBaseHeadErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetPullRequestByBaseHeadResponses = {
    /**
     * PullRequest
     */
    200: PullRequest;
};

export type RepoGetPullRequestByBaseHeadResponse = RepoGetPullRequestByBaseHeadResponses[keyof RepoGetPullRequestByBaseHeadResponses];

export type RepoGetPullRequestData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}';
};

export type RepoGetPullRequestErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetPullRequestResponses = {
    /**
     * PullRequest
     */
    200: PullRequest;
};

export type RepoGetPullRequestResponse = RepoGetPullRequestResponses[keyof RepoGetPullRequestResponses];

export type RepoEditPullRequestData = {
    body?: EditPullRequestOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to edit
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}';
};

export type RepoEditPullRequestErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    409: unknown;
    /**
     * APIError is error format response
     */
    412: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoEditPullRequestResponses = {
    /**
     * PullRequest
     */
    201: PullRequest;
};

export type RepoEditPullRequestResponse = RepoEditPullRequestResponses[keyof RepoEditPullRequestResponses];

export type RepoDownloadPullDiffOrPatchData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
        /**
         * whether the output is diff or patch
         */
        diffType: 'diff' | 'patch';
    };
    query?: {
        /**
         * whether to include binary file changes. if true, the diff is applicable with `git apply`
         */
        binary?: boolean;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}.{diffType}';
};

export type RepoDownloadPullDiffOrPatchErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDownloadPullDiffOrPatchResponses = {
    /**
     * APIString is a string response
     */
    200: string;
};

export type RepoDownloadPullDiffOrPatchResponse = RepoDownloadPullDiffOrPatchResponses[keyof RepoDownloadPullDiffOrPatchResponses];

export type RepoGetPullRequestCommitsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * include verification for every commit (disable for speedup, default 'true')
         */
        verification?: boolean;
        /**
         * include a list of affected files for every commit (disable for speedup, default 'true')
         */
        files?: boolean;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/commits';
};

export type RepoGetPullRequestCommitsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetPullRequestCommitsResponses = {
    /**
     * CommitList
     */
    200: Array<Commit>;
};

export type RepoGetPullRequestCommitsResponse = RepoGetPullRequestCommitsResponses[keyof RepoGetPullRequestCommitsResponses];

export type RepoGetPullRequestFilesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: {
        /**
         * skip to given file
         */
        'skip-to'?: string;
        /**
         * whitespace behavior
         */
        whitespace?: 'ignore-all' | 'ignore-change' | 'ignore-eol' | 'show-all';
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/files';
};

export type RepoGetPullRequestFilesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetPullRequestFilesResponses = {
    /**
     * ChangedFileList
     */
    200: Array<ChangedFile>;
};

export type RepoGetPullRequestFilesResponse = RepoGetPullRequestFilesResponses[keyof RepoGetPullRequestFilesResponses];

export type RepoCancelScheduledAutoMergeData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to merge
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/merge';
};

export type RepoCancelScheduledAutoMergeErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCancelScheduledAutoMergeResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoPullRequestIsMergedData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/merge';
};

export type RepoPullRequestIsMergedErrors = {
    /**
     * pull request has not been merged
     */
    404: unknown;
};

export type RepoPullRequestIsMergedResponses = {
    /**
     * pull request has been merged
     */
    204: unknown;
};

export type RepoMergePullRequestData = {
    body?: MergePullRequestOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to merge
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/merge';
};

export type RepoMergePullRequestErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIEmpty is an empty response
     */
    405: unknown;
    /**
     * APIError is error format response
     */
    409: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoMergePullRequestResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoDeletePullReviewRequestsData = {
    body: PullReviewRequestOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers';
};

export type RepoDeletePullReviewRequestsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoDeletePullReviewRequestsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoCreatePullReviewRequestsData = {
    body: PullReviewRequestOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/requested_reviewers';
};

export type RepoCreatePullReviewRequestsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoCreatePullReviewRequestsResponses = {
    /**
     * PullReviewList
     */
    201: Array<PullReview>;
};

export type RepoCreatePullReviewRequestsResponse = RepoCreatePullReviewRequestsResponses[keyof RepoCreatePullReviewRequestsResponses];

export type RepoListPullReviewsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews';
};

export type RepoListPullReviewsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListPullReviewsResponses = {
    /**
     * PullReviewList
     */
    200: Array<PullReview>;
};

export type RepoListPullReviewsResponse = RepoListPullReviewsResponses[keyof RepoListPullReviewsResponses];

export type RepoCreatePullReviewData = {
    body: CreatePullReviewOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews';
};

export type RepoCreatePullReviewErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoCreatePullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoCreatePullReviewResponse = RepoCreatePullReviewResponses[keyof RepoCreatePullReviewResponses];

export type RepoDeletePullReviewData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}';
};

export type RepoDeletePullReviewErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeletePullReviewResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetPullReviewData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}';
};

export type RepoGetPullReviewErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoGetPullReviewResponse = RepoGetPullReviewResponses[keyof RepoGetPullReviewResponses];

export type RepoSubmitPullReviewData = {
    body: SubmitPullReviewOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}';
};

export type RepoSubmitPullReviewErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoSubmitPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoSubmitPullReviewResponse = RepoSubmitPullReviewResponses[keyof RepoSubmitPullReviewResponses];

export type RepoGetPullReviewCommentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments';
};

export type RepoGetPullReviewCommentsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetPullReviewCommentsResponses = {
    /**
     * PullCommentList
     */
    200: Array<PullReviewComment>;
};

export type RepoGetPullReviewCommentsResponse = RepoGetPullReviewCommentsResponses[keyof RepoGetPullReviewCommentsResponses];

export type RepoDismissPullReviewData = {
    body: DismissPullReviewOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals';
};

export type RepoDismissPullReviewErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoDismissPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoDismissPullReviewResponse = RepoDismissPullReviewResponses[keyof RepoDismissPullReviewResponses];

export type RepoUnDismissPullReviewData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request
         */
        index: number;
        /**
         * id of the review
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals';
};

export type RepoUnDismissPullReviewErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoUnDismissPullReviewResponses = {
    /**
     * PullReview
     */
    200: PullReview;
};

export type RepoUnDismissPullReviewResponse = RepoUnDismissPullReviewResponses[keyof RepoUnDismissPullReviewResponses];

export type RepoUpdatePullRequestData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * index of the pull request to get
         */
        index: number;
    };
    query?: {
        /**
         * how to update pull request
         */
        style?: 'merge' | 'rebase';
    };
    url: '/repos/{owner}/{repo}/pulls/{index}/update';
};

export type RepoUpdatePullRequestErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoUpdatePullRequestResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoListPushMirrorsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/push_mirrors';
};

export type RepoListPushMirrorsErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListPushMirrorsResponses = {
    /**
     * PushMirrorList
     */
    200: Array<PushMirror>;
};

export type RepoListPushMirrorsResponse = RepoListPushMirrorsResponses[keyof RepoListPushMirrorsResponses];

export type RepoAddPushMirrorData = {
    body?: CreatePushMirrorOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors';
};

export type RepoAddPushMirrorErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoAddPushMirrorResponses = {
    /**
     * PushMirror
     */
    200: PushMirror;
};

export type RepoAddPushMirrorResponse = RepoAddPushMirrorResponses[keyof RepoAddPushMirrorResponses];

export type RepoPushMirrorSyncData = {
    body?: never;
    path: {
        /**
         * owner of the repo to sync
         */
        owner: string;
        /**
         * name of the repo to sync
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors-sync';
};

export type RepoPushMirrorSyncErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoPushMirrorSyncResponses = {
    /**
     * APIEmpty is an empty response
     */
    200: unknown;
};

export type RepoDeletePushMirrorData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * remote name of the pushMirror
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors/{name}';
};

export type RepoDeletePushMirrorErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeletePushMirrorResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetPushMirrorByRemoteNameData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * remote name of push mirror
         */
        name: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/push_mirrors/{name}';
};

export type RepoGetPushMirrorByRemoteNameErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetPushMirrorByRemoteNameResponses = {
    /**
     * PushMirror
     */
    200: PushMirror;
};

export type RepoGetPushMirrorByRemoteNameResponse = RepoGetPushMirrorByRemoteNameResponses[keyof RepoGetPushMirrorByRemoteNameResponses];

export type RepoGetRawFileData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * path of the file to get, it should be "{ref}/{filepath}". If there is no ref could be inferred, it will be treated as the default branch
         */
        filepath: string;
    };
    query?: {
        /**
         * The name of the commit/branch/tag. Default the repositorys default branch
         */
        ref?: string;
    };
    url: '/repos/{owner}/{repo}/raw/{filepath}';
};

export type RepoGetRawFileErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: Blob | File;
};

export type RepoGetRawFileError = RepoGetRawFileErrors[keyof RepoGetRawFileErrors];

export type RepoGetRawFileResponses = {
    /**
     * Returns raw file content.
     */
    200: unknown;
};

export type RepoListReleasesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * filter (exclude / include) drafts, if you dont have repo write access none will show
         */
        draft?: boolean;
        /**
         * filter (exclude / include) pre-releases
         */
        'pre-release'?: boolean;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/releases';
};

export type RepoListReleasesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListReleasesResponses = {
    /**
     * ReleaseList
     */
    200: Array<Release>;
};

export type RepoListReleasesResponse = RepoListReleasesResponses[keyof RepoListReleasesResponses];

export type RepoCreateReleaseData = {
    body?: CreateReleaseOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases';
};

export type RepoCreateReleaseErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoCreateReleaseResponses = {
    /**
     * Release
     */
    201: Release;
};

export type RepoCreateReleaseResponse = RepoCreateReleaseResponses[keyof RepoCreateReleaseResponses];

export type RepoGetLatestReleaseData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/latest';
};

export type RepoGetLatestReleaseErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetLatestReleaseResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoGetLatestReleaseResponse = RepoGetLatestReleaseResponses[keyof RepoGetLatestReleaseResponses];

export type RepoDeleteReleaseByTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * tag name of the release to delete
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/tags/{tag}';
};

export type RepoDeleteReleaseByTagErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoDeleteReleaseByTagResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetReleaseByTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * tag name of the release to get
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/tags/{tag}';
};

export type RepoGetReleaseByTagErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetReleaseByTagResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoGetReleaseByTagResponse = RepoGetReleaseByTagResponses[keyof RepoGetReleaseByTagResponses];

export type RepoDeleteReleaseData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release to delete
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}';
};

export type RepoDeleteReleaseErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoDeleteReleaseResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetReleaseData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}';
};

export type RepoGetReleaseErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetReleaseResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoGetReleaseResponse = RepoGetReleaseResponses[keyof RepoGetReleaseResponses];

export type RepoEditReleaseData = {
    body?: EditReleaseOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release to edit
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}';
};

export type RepoEditReleaseErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoEditReleaseResponses = {
    /**
     * Release
     */
    200: Release;
};

export type RepoEditReleaseResponse = RepoEditReleaseResponses[keyof RepoEditReleaseResponses];

export type RepoListReleaseAttachmentsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets';
};

export type RepoListReleaseAttachmentsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListReleaseAttachmentsResponses = {
    /**
     * AttachmentList
     */
    200: Array<Attachment>;
};

export type RepoListReleaseAttachmentsResponse = RepoListReleaseAttachmentsResponses[keyof RepoListReleaseAttachmentsResponses];

export type RepoCreateReleaseAttachmentData = {
    body?: {
        /**
         * attachment to upload
         */
        attachment?: Blob | File;
    };
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
    };
    query?: {
        /**
         * name of the attachment
         */
        name?: string;
    };
    url: '/repos/{owner}/{repo}/releases/{id}/assets';
};

export type RepoCreateReleaseAttachmentErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoCreateReleaseAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type RepoCreateReleaseAttachmentResponse = RepoCreateReleaseAttachmentResponses[keyof RepoCreateReleaseAttachmentResponses];

export type RepoDeleteReleaseAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
        /**
         * id of the attachment to delete
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}';
};

export type RepoDeleteReleaseAttachmentErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteReleaseAttachmentResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetReleaseAttachmentData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
        /**
         * id of the attachment to get
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}';
};

export type RepoGetReleaseAttachmentErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetReleaseAttachmentResponses = {
    /**
     * Attachment
     */
    200: Attachment;
};

export type RepoGetReleaseAttachmentResponse = RepoGetReleaseAttachmentResponses[keyof RepoGetReleaseAttachmentResponses];

export type RepoEditReleaseAttachmentData = {
    body?: EditAttachmentOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the release
         */
        id: number;
        /**
         * id of the attachment to edit
         */
        attachment_id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}';
};

export type RepoEditReleaseAttachmentErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoEditReleaseAttachmentResponses = {
    /**
     * Attachment
     */
    201: Attachment;
};

export type RepoEditReleaseAttachmentResponse = RepoEditReleaseAttachmentResponses[keyof RepoEditReleaseAttachmentResponses];

export type RepoGetReviewersData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/reviewers';
};

export type RepoGetReviewersErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetReviewersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoGetReviewersResponse = RepoGetReviewersResponses[keyof RepoGetReviewersResponses];

export type RepoSigningKeyData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/signing-key.gpg';
};

export type RepoSigningKeyResponses = {
    /**
     * GPG armored public key
     */
    200: string;
};

export type RepoSigningKeyResponse = RepoSigningKeyResponses[keyof RepoSigningKeyResponses];

export type RepoListStargazersData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/stargazers';
};

export type RepoListStargazersErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListStargazersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoListStargazersResponse = RepoListStargazersResponses[keyof RepoListStargazersResponses];

export type RepoListStatusesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: {
        /**
         * type of sort
         */
        sort?: 'oldest' | 'recentupdate' | 'leastupdate' | 'leastindex' | 'highestindex';
        /**
         * type of state
         */
        state?: 'pending' | 'success' | 'error' | 'failure' | 'warning';
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/statuses/{sha}';
};

export type RepoListStatusesErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListStatusesResponses = {
    /**
     * CommitStatusList
     */
    200: Array<CommitStatus>;
};

export type RepoListStatusesResponse = RepoListStatusesResponses[keyof RepoListStatusesResponses];

export type RepoCreateStatusData = {
    body?: CreateStatusOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * sha of the commit
         */
        sha: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/statuses/{sha}';
};

export type RepoCreateStatusErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoCreateStatusResponses = {
    /**
     * CommitStatus
     */
    201: CommitStatus;
};

export type RepoCreateStatusResponse = RepoCreateStatusResponses[keyof RepoCreateStatusResponses];

export type RepoListSubscribersData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/subscribers';
};

export type RepoListSubscribersErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListSubscribersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type RepoListSubscribersResponse = RepoListSubscribersResponses[keyof RepoListSubscribersResponses];

export type UserCurrentDeleteSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/subscription';
};

export type UserCurrentDeleteSubscriptionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentDeleteSubscriptionResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentCheckSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/subscription';
};

export type UserCurrentCheckSubscriptionErrors = {
    /**
     * User is not watching this repo or repo do not exist
     */
    404: unknown;
};

export type UserCurrentCheckSubscriptionResponses = {
    /**
     * WatchInfo
     */
    200: WatchInfo;
};

export type UserCurrentCheckSubscriptionResponse = UserCurrentCheckSubscriptionResponses[keyof UserCurrentCheckSubscriptionResponses];

export type UserCurrentPutSubscriptionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/subscription';
};

export type UserCurrentPutSubscriptionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentPutSubscriptionResponses = {
    /**
     * WatchInfo
     */
    200: WatchInfo;
};

export type UserCurrentPutSubscriptionResponse = UserCurrentPutSubscriptionResponses[keyof UserCurrentPutSubscriptionResponses];

export type RepoListTagProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections';
};

export type RepoListTagProtectionResponses = {
    /**
     * TagProtectionList
     */
    200: Array<TagProtection>;
};

export type RepoListTagProtectionResponse = RepoListTagProtectionResponses[keyof RepoListTagProtectionResponses];

export type RepoCreateTagProtectionData = {
    body?: CreateTagProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections';
};

export type RepoCreateTagProtectionErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCreateTagProtectionResponses = {
    /**
     * TagProtection
     */
    201: TagProtection;
};

export type RepoCreateTagProtectionResponse = RepoCreateTagProtectionResponses[keyof RepoCreateTagProtectionResponses];

export type RepoDeleteTagProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of protected tag
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections/{id}';
};

export type RepoDeleteTagProtectionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoDeleteTagProtectionResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetTagProtectionData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of the tag protect to get
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections/{id}';
};

export type RepoGetTagProtectionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetTagProtectionResponses = {
    /**
     * TagProtection
     */
    200: TagProtection;
};

export type RepoGetTagProtectionResponse = RepoGetTagProtectionResponses[keyof RepoGetTagProtectionResponses];

export type RepoEditTagProtectionData = {
    body?: EditTagProtectionOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * id of protected tag
         */
        id: number;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tag_protections/{id}';
};

export type RepoEditTagProtectionErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoEditTagProtectionResponses = {
    /**
     * TagProtection
     */
    200: TagProtection;
};

export type RepoEditTagProtectionResponse = RepoEditTagProtectionResponses[keyof RepoEditTagProtectionResponses];

export type RepoListTagsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results, default maximum page size is 50
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/tags';
};

export type RepoListTagsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListTagsResponses = {
    /**
     * TagList
     */
    200: Array<Tag>;
};

export type RepoListTagsResponse = RepoListTagsResponses[keyof RepoListTagsResponses];

export type RepoCreateTagData = {
    body?: CreateTagOption;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tags';
};

export type RepoCreateTagErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIEmpty is an empty response
     */
    405: unknown;
    /**
     * APIConflict is a conflict empty response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCreateTagResponses = {
    /**
     * Tag
     */
    200: Tag;
};

export type RepoCreateTagResponse = RepoCreateTagResponses[keyof RepoCreateTagResponses];

export type RepoDeleteTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of tag to delete
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tags/{tag}';
};

export type RepoDeleteTagErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIEmpty is an empty response
     */
    405: unknown;
    /**
     * APIConflict is a conflict empty response
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoDeleteTagResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetTagData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of tag
         */
        tag: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/tags/{tag}';
};

export type RepoGetTagErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetTagResponses = {
    /**
     * Tag
     */
    200: Tag;
};

export type RepoGetTagResponse = RepoGetTagResponses[keyof RepoGetTagResponses];

export type RepoListTeamsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams';
};

export type RepoListTeamsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListTeamsResponses = {
    /**
     * TeamList
     */
    200: Array<Team>;
};

export type RepoListTeamsResponse = RepoListTeamsResponses[keyof RepoListTeamsResponses];

export type RepoDeleteTeamData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * team name
         */
        team: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams/{team}';
};

export type RepoDeleteTeamErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    405: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoDeleteTeamResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoCheckTeamData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * team name
         */
        team: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams/{team}';
};

export type RepoCheckTeamErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    405: unknown;
};

export type RepoCheckTeamResponses = {
    /**
     * Team
     */
    200: Team;
};

export type RepoCheckTeamResponse = RepoCheckTeamResponses[keyof RepoCheckTeamResponses];

export type RepoAddTeamData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * team name
         */
        team: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/teams/{team}';
};

export type RepoAddTeamErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    405: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoAddTeamResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoTrackedTimesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * optional filter by user (available for issue managers)
         */
        user?: string;
        /**
         * Only show times updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show times updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/times';
};

export type RepoTrackedTimesErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type RepoTrackedTimesResponse = RepoTrackedTimesResponses[keyof RepoTrackedTimesResponses];

export type UserTrackedTimesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * username of user
         */
        user: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/times/{user}';
};

export type UserTrackedTimesErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type UserTrackedTimesResponse = UserTrackedTimesResponses[keyof UserTrackedTimesResponses];

export type RepoListTopicsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/topics';
};

export type RepoListTopicsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoListTopicsResponses = {
    /**
     * TopicNames
     */
    200: TopicName;
};

export type RepoListTopicsResponse = RepoListTopicsResponses[keyof RepoListTopicsResponses];

export type RepoUpdateTopicsData = {
    body?: RepoTopicOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/topics';
};

export type RepoUpdateTopicsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIInvalidTopicsError is error format response to invalid topics
     */
    422: unknown;
};

export type RepoUpdateTopicsResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoDeleteTopicData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the topic to delete
         */
        topic: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/topics/{topic}';
};

export type RepoDeleteTopicErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIInvalidTopicsError is error format response to invalid topics
     */
    422: unknown;
};

export type RepoDeleteTopicResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoAddTopicData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the topic to add
         */
        topic: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/topics/{topic}';
};

export type RepoAddTopicErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIInvalidTopicsError is error format response to invalid topics
     */
    422: unknown;
};

export type RepoAddTopicResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoTransferData = {
    /**
     * Transfer Options
     */
    body: TransferRepoOption;
    path: {
        /**
         * owner of the repo to transfer
         */
        owner: string;
        /**
         * name of the repo to transfer
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/transfer';
};

export type RepoTransferErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type RepoTransferResponses = {
    /**
     * Repository
     */
    202: Repository;
};

export type RepoTransferResponse = RepoTransferResponses[keyof RepoTransferResponses];

export type AcceptRepoTransferData = {
    body?: never;
    path: {
        /**
         * owner of the repo to transfer
         */
        owner: string;
        /**
         * name of the repo to transfer
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/transfer/accept';
};

export type AcceptRepoTransferErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type AcceptRepoTransferResponses = {
    /**
     * Repository
     */
    202: Repository;
};

export type AcceptRepoTransferResponse = AcceptRepoTransferResponses[keyof AcceptRepoTransferResponses];

export type RejectRepoTransferData = {
    body?: never;
    path: {
        /**
         * owner of the repo to transfer
         */
        owner: string;
        /**
         * name of the repo to transfer
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/transfer/reject';
};

export type RejectRepoTransferErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RejectRepoTransferResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RejectRepoTransferResponse = RejectRepoTransferResponses[keyof RejectRepoTransferResponses];

export type RepoCreateWikiPageData = {
    body?: CreateWikiPageOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/new';
};

export type RepoCreateWikiPageErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoCreateWikiPageResponses = {
    /**
     * WikiPage
     */
    201: WikiPage;
};

export type RepoCreateWikiPageResponse = RepoCreateWikiPageResponses[keyof RepoCreateWikiPageResponses];

export type RepoDeleteWikiPageData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/page/{pageName}';
};

export type RepoDeleteWikiPageErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoDeleteWikiPageResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type RepoGetWikiPageData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/page/{pageName}';
};

export type RepoGetWikiPageErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetWikiPageResponses = {
    /**
     * WikiPage
     */
    200: WikiPage;
};

export type RepoGetWikiPageResponse = RepoGetWikiPageResponses[keyof RepoGetWikiPageResponses];

export type RepoEditWikiPageData = {
    body?: CreateWikiPageOptions;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: never;
    url: '/repos/{owner}/{repo}/wiki/page/{pageName}';
};

export type RepoEditWikiPageErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIRepoArchivedError is an error that is raised when an archived repo should be modified
     */
    423: unknown;
};

export type RepoEditWikiPageResponses = {
    /**
     * WikiPage
     */
    200: WikiPage;
};

export type RepoEditWikiPageResponse = RepoEditWikiPageResponses[keyof RepoEditWikiPageResponses];

export type RepoGetWikiPagesData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/repos/{owner}/{repo}/wiki/pages';
};

export type RepoGetWikiPagesErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetWikiPagesResponses = {
    /**
     * WikiPageList
     */
    200: Array<WikiPageMetaData>;
};

export type RepoGetWikiPagesResponse = RepoGetWikiPagesResponses[keyof RepoGetWikiPagesResponses];

export type RepoGetWikiPageRevisionsData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
        /**
         * name of the page
         */
        pageName: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
    };
    url: '/repos/{owner}/{repo}/wiki/revisions/{pageName}';
};

export type RepoGetWikiPageRevisionsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetWikiPageRevisionsResponses = {
    /**
     * WikiCommitList
     */
    200: WikiCommitList;
};

export type RepoGetWikiPageRevisionsResponse = RepoGetWikiPageRevisionsResponses[keyof RepoGetWikiPageRevisionsResponses];

export type GenerateRepoData = {
    body?: GenerateRepoOption;
    path: {
        /**
         * name of the template repository owner
         */
        template_owner: string;
        /**
         * name of the template repository
         */
        template_repo: string;
    };
    query?: never;
    url: '/repos/{template_owner}/{template_repo}/generate';
};

export type GenerateRepoErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type GenerateRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type GenerateRepoResponse = GenerateRepoResponses[keyof GenerateRepoResponses];

export type RepoGetByIdData = {
    body?: never;
    path: {
        /**
         * id of the repo to get
         */
        id: number;
    };
    query?: never;
    url: '/repositories/{id}';
};

export type RepoGetByIdErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type RepoGetByIdResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type RepoGetByIdResponse = RepoGetByIdResponses[keyof RepoGetByIdResponses];

export type GetGeneralApiSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/api';
};

export type GetGeneralApiSettingsResponses = {
    /**
     * GeneralAPISettings
     */
    200: GeneralApiSettings;
};

export type GetGeneralApiSettingsResponse = GetGeneralApiSettingsResponses[keyof GetGeneralApiSettingsResponses];

export type GetGeneralAttachmentSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/attachment';
};

export type GetGeneralAttachmentSettingsResponses = {
    /**
     * GeneralAttachmentSettings
     */
    200: GeneralAttachmentSettings;
};

export type GetGeneralAttachmentSettingsResponse = GetGeneralAttachmentSettingsResponses[keyof GetGeneralAttachmentSettingsResponses];

export type GetGeneralRepositorySettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/repository';
};

export type GetGeneralRepositorySettingsResponses = {
    /**
     * GeneralRepoSettings
     */
    200: GeneralRepoSettings;
};

export type GetGeneralRepositorySettingsResponse = GetGeneralRepositorySettingsResponses[keyof GetGeneralRepositorySettingsResponses];

export type GetGeneralUiSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/settings/ui';
};

export type GetGeneralUiSettingsResponses = {
    /**
     * GeneralUISettings
     */
    200: GeneralUiSettings;
};

export type GetGeneralUiSettingsResponse = GetGeneralUiSettingsResponses[keyof GetGeneralUiSettingsResponses];

export type GetSigningKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/signing-key.gpg';
};

export type GetSigningKeyResponses = {
    /**
     * GPG armored public key
     */
    200: string;
};

export type GetSigningKeyResponse = GetSigningKeyResponses[keyof GetSigningKeyResponses];

export type OrgDeleteTeamData = {
    body?: never;
    path: {
        /**
         * id of the team to delete
         */
        id: number;
    };
    query?: never;
    url: '/teams/{id}';
};

export type OrgDeleteTeamErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgDeleteTeamResponses = {
    /**
     * team deleted
     */
    204: unknown;
};

export type OrgGetTeamData = {
    body?: never;
    path: {
        /**
         * id of the team to get
         */
        id: number;
    };
    query?: never;
    url: '/teams/{id}';
};

export type OrgGetTeamErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgGetTeamResponses = {
    /**
     * Team
     */
    200: Team;
};

export type OrgGetTeamResponse = OrgGetTeamResponses[keyof OrgGetTeamResponses];

export type OrgEditTeamData = {
    body?: EditTeamOption;
    path: {
        /**
         * id of the team to edit
         */
        id: number;
    };
    query?: never;
    url: '/teams/{id}';
};

export type OrgEditTeamErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgEditTeamResponses = {
    /**
     * Team
     */
    200: Team;
};

export type OrgEditTeamResponse = OrgEditTeamResponses[keyof OrgEditTeamResponses];

export type OrgListTeamActivityFeedsData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
    };
    query?: {
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/teams/{id}/activities/feeds';
};

export type OrgListTeamActivityFeedsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListTeamActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type OrgListTeamActivityFeedsResponse = OrgListTeamActivityFeedsResponses[keyof OrgListTeamActivityFeedsResponses];

export type OrgListTeamMembersData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/teams/{id}/members';
};

export type OrgListTeamMembersErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListTeamMembersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type OrgListTeamMembersResponse = OrgListTeamMembersResponses[keyof OrgListTeamMembersResponses];

export type OrgRemoveTeamMemberData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * username of the user to remove
         */
        username: string;
    };
    query?: never;
    url: '/teams/{id}/members/{username}';
};

export type OrgRemoveTeamMemberErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgRemoveTeamMemberResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListTeamMemberData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * username of the member to list
         */
        username: string;
    };
    query?: never;
    url: '/teams/{id}/members/{username}';
};

export type OrgListTeamMemberErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListTeamMemberResponses = {
    /**
     * User
     */
    200: User;
};

export type OrgListTeamMemberResponse = OrgListTeamMemberResponses[keyof OrgListTeamMemberResponses];

export type OrgAddTeamMemberData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * username of the user to add
         */
        username: string;
    };
    query?: never;
    url: '/teams/{id}/members/{username}';
};

export type OrgAddTeamMemberErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgAddTeamMemberResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListTeamReposData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/teams/{id}/repos';
};

export type OrgListTeamReposErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListTeamReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type OrgListTeamReposResponse = OrgListTeamReposResponses[keyof OrgListTeamReposResponses];

export type OrgRemoveTeamRepositoryData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * organization that owns the repo to remove
         */
        org: string;
        /**
         * name of the repo to remove
         */
        repo: string;
    };
    query?: never;
    url: '/teams/{id}/repos/{org}/{repo}';
};

export type OrgRemoveTeamRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgRemoveTeamRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type OrgListTeamRepoData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * organization that owns the repo to list
         */
        org: string;
        /**
         * name of the repo to list
         */
        repo: string;
    };
    query?: never;
    url: '/teams/{id}/repos/{org}/{repo}';
};

export type OrgListTeamRepoErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListTeamRepoResponses = {
    /**
     * Repository
     */
    200: Repository;
};

export type OrgListTeamRepoResponse = OrgListTeamRepoResponses[keyof OrgListTeamRepoResponses];

export type OrgAddTeamRepositoryData = {
    body?: never;
    path: {
        /**
         * id of the team
         */
        id: number;
        /**
         * organization that owns the repo to add
         */
        org: string;
        /**
         * name of the repo to add
         */
        repo: string;
    };
    query?: never;
    url: '/teams/{id}/repos/{org}/{repo}';
};

export type OrgAddTeamRepositoryErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgAddTeamRepositoryResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type TopicSearchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * keywords to search
         */
        q: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/topics/search';
};

export type TopicSearchErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type TopicSearchResponses = {
    /**
     * TopicListResponse
     */
    200: Array<TopicResponse>;
};

export type TopicSearchResponse = TopicSearchResponses[keyof TopicSearchResponses];

export type UserGetCurrentData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user';
};

export type UserGetCurrentResponses = {
    /**
     * User
     */
    200: User;
};

export type UserGetCurrentResponse = UserGetCurrentResponses[keyof UserGetCurrentResponses];

export type UserGetRunnerRegistrationTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/actions/runners/registration-token';
};

export type UserGetRunnerRegistrationTokenResponses = {
    /**
     * RegistrationToken is response related to registration token
     */
    200: unknown;
};

export type DeleteUserSecretData = {
    body?: never;
    path: {
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/user/actions/secrets/{secretname}';
};

export type DeleteUserSecretErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeleteUserSecretResponses = {
    /**
     * delete one secret of the user
     */
    204: unknown;
};

export type UpdateUserSecretData = {
    body?: CreateOrUpdateSecretOption;
    path: {
        /**
         * name of the secret
         */
        secretname: string;
    };
    query?: never;
    url: '/user/actions/secrets/{secretname}';
};

export type UpdateUserSecretErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UpdateUserSecretResponses = {
    /**
     * response when creating a secret
     */
    201: unknown;
    /**
     * response when updating a secret
     */
    204: unknown;
};

export type GetUserVariablesListData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/actions/variables';
};

export type GetUserVariablesListErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetUserVariablesListResponses = {
    /**
     * VariableList
     */
    200: Array<ActionVariable>;
};

export type GetUserVariablesListResponse = GetUserVariablesListResponses[keyof GetUserVariablesListResponses];

export type DeleteUserVariableData = {
    body?: never;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type DeleteUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type DeleteUserVariableResponses = {
    /**
     * response when deleting a variable
     */
    201: unknown;
    /**
     * response when deleting a variable
     */
    204: unknown;
};

export type GetUserVariableData = {
    body?: never;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type GetUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetUserVariableResponses = {
    /**
     * ActionVariable
     */
    200: ActionVariable;
};

export type GetUserVariableResponse = GetUserVariableResponses[keyof GetUserVariableResponses];

export type CreateUserVariableData = {
    body?: CreateVariableOption;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type CreateUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type CreateUserVariableResponses = {
    /**
     * response when creating a variable
     */
    201: unknown;
    /**
     * response when creating a variable
     */
    204: unknown;
};

export type UpdateUserVariableData = {
    body?: UpdateVariableOption;
    path: {
        /**
         * name of the variable
         */
        variablename: string;
    };
    query?: never;
    url: '/user/actions/variables/{variablename}';
};

export type UpdateUserVariableErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UpdateUserVariableResponses = {
    /**
     * response when updating a variable
     */
    201: unknown;
    /**
     * response when updating a variable
     */
    204: unknown;
};

export type UserGetOauth2ApplicationData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/applications/oauth2';
};

export type UserGetOauth2ApplicationResponses = {
    /**
     * OAuth2ApplicationList represents a list of OAuth2 applications.
     */
    200: Array<OAuth2Application>;
};

export type UserGetOauth2ApplicationResponse = UserGetOauth2ApplicationResponses[keyof UserGetOauth2ApplicationResponses];

export type UserCreateOAuth2ApplicationData = {
    body: CreateOAuth2ApplicationOptions;
    path?: never;
    query?: never;
    url: '/user/applications/oauth2';
};

export type UserCreateOAuth2ApplicationErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
};

export type UserCreateOAuth2ApplicationResponses = {
    /**
     * OAuth2Application
     */
    201: OAuth2Application;
};

export type UserCreateOAuth2ApplicationResponse = UserCreateOAuth2ApplicationResponses[keyof UserCreateOAuth2ApplicationResponses];

export type UserDeleteOAuth2ApplicationData = {
    body?: never;
    path: {
        /**
         * token to be deleted
         */
        id: number;
    };
    query?: never;
    url: '/user/applications/oauth2/{id}';
};

export type UserDeleteOAuth2ApplicationErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserDeleteOAuth2ApplicationResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserGetOAuth2ApplicationData = {
    body?: never;
    path: {
        /**
         * Application ID to be found
         */
        id: number;
    };
    query?: never;
    url: '/user/applications/oauth2/{id}';
};

export type UserGetOAuth2ApplicationErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserGetOAuth2ApplicationResponses = {
    /**
     * OAuth2Application
     */
    200: OAuth2Application;
};

export type UserGetOAuth2ApplicationResponse = UserGetOAuth2ApplicationResponses[keyof UserGetOAuth2ApplicationResponses];

export type UserUpdateOAuth2ApplicationData = {
    body: CreateOAuth2ApplicationOptions;
    path: {
        /**
         * application to be updated
         */
        id: number;
    };
    query?: never;
    url: '/user/applications/oauth2/{id}';
};

export type UserUpdateOAuth2ApplicationErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserUpdateOAuth2ApplicationResponses = {
    /**
     * OAuth2Application
     */
    200: OAuth2Application;
};

export type UserUpdateOAuth2ApplicationResponse = UserUpdateOAuth2ApplicationResponses[keyof UserUpdateOAuth2ApplicationResponses];

export type UserDeleteAvatarData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/avatar';
};

export type UserDeleteAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserUpdateAvatarData = {
    body?: UpdateUserAvatarOption;
    path?: never;
    query?: never;
    url: '/user/avatar';
};

export type UserUpdateAvatarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserListBlocksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/blocks';
};

export type UserListBlocksResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserListBlocksResponse = UserListBlocksResponses[keyof UserListBlocksResponses];

export type UserUnblockUserData = {
    body?: never;
    path: {
        /**
         * user to unblock
         */
        username: string;
    };
    query?: never;
    url: '/user/blocks/{username}';
};

export type UserUnblockUserErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type UserUnblockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCheckUserBlockData = {
    body?: never;
    path: {
        /**
         * user to check
         */
        username: string;
    };
    query?: never;
    url: '/user/blocks/{username}';
};

export type UserCheckUserBlockErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCheckUserBlockResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserBlockUserData = {
    body?: never;
    path: {
        /**
         * user to block
         */
        username: string;
    };
    query?: {
        /**
         * optional note for the block
         */
        note?: string;
    };
    url: '/user/blocks/{username}';
};

export type UserBlockUserErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type UserBlockUserResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserDeleteEmailData = {
    body?: DeleteEmailOption;
    path?: never;
    query?: never;
    url: '/user/emails';
};

export type UserDeleteEmailErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserDeleteEmailResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserListEmailsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/emails';
};

export type UserListEmailsResponses = {
    /**
     * EmailList
     */
    200: Array<Email>;
};

export type UserListEmailsResponse = UserListEmailsResponses[keyof UserListEmailsResponses];

export type UserAddEmailData = {
    body?: CreateEmailOption;
    path?: never;
    query?: never;
    url: '/user/emails';
};

export type UserAddEmailErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type UserAddEmailResponses = {
    /**
     * EmailList
     */
    201: Array<Email>;
};

export type UserAddEmailResponse = UserAddEmailResponses[keyof UserAddEmailResponses];

export type UserCurrentListFollowersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/followers';
};

export type UserCurrentListFollowersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserCurrentListFollowersResponse = UserCurrentListFollowersResponses[keyof UserCurrentListFollowersResponses];

export type UserCurrentListFollowingData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/following';
};

export type UserCurrentListFollowingResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserCurrentListFollowingResponse = UserCurrentListFollowingResponses[keyof UserCurrentListFollowingResponses];

export type UserCurrentDeleteFollowData = {
    body?: never;
    path: {
        /**
         * username of user to unfollow
         */
        username: string;
    };
    query?: never;
    url: '/user/following/{username}';
};

export type UserCurrentDeleteFollowErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentDeleteFollowResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentCheckFollowingData = {
    body?: never;
    path: {
        /**
         * username of followed user
         */
        username: string;
    };
    query?: never;
    url: '/user/following/{username}';
};

export type UserCurrentCheckFollowingErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentCheckFollowingResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentPutFollowData = {
    body?: never;
    path: {
        /**
         * username of user to follow
         */
        username: string;
    };
    query?: never;
    url: '/user/following/{username}';
};

export type UserCurrentPutFollowErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentPutFollowResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type GetVerificationTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/gpg_key_token';
};

export type GetVerificationTokenErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type GetVerificationTokenResponses = {
    /**
     * APIString is a string response
     */
    200: string;
};

export type GetVerificationTokenResponse = GetVerificationTokenResponses[keyof GetVerificationTokenResponses];

export type UserVerifyGpgKeyData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/gpg_key_verify';
};

export type UserVerifyGpgKeyErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type UserVerifyGpgKeyResponses = {
    /**
     * GPGKey
     */
    201: GpgKey;
};

export type UserVerifyGpgKeyResponse = UserVerifyGpgKeyResponses[keyof UserVerifyGpgKeyResponses];

export type UserCurrentListGpgKeysData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/gpg_keys';
};

export type UserCurrentListGpgKeysResponses = {
    /**
     * GPGKeyList
     */
    200: Array<GpgKey>;
};

export type UserCurrentListGpgKeysResponse = UserCurrentListGpgKeysResponses[keyof UserCurrentListGpgKeysResponses];

export type UserCurrentPostGpgKeyData = {
    body?: CreateGpgKeyOption;
    path?: never;
    query?: never;
    url: '/user/gpg_keys';
};

export type UserCurrentPostGpgKeyErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type UserCurrentPostGpgKeyResponses = {
    /**
     * GPGKey
     */
    201: GpgKey;
};

export type UserCurrentPostGpgKeyResponse = UserCurrentPostGpgKeyResponses[keyof UserCurrentPostGpgKeyResponses];

export type UserCurrentDeleteGpgKeyData = {
    body?: never;
    path: {
        /**
         * id of key to delete
         */
        id: number;
    };
    query?: never;
    url: '/user/gpg_keys/{id}';
};

export type UserCurrentDeleteGpgKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentDeleteGpgKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentGetGpgKeyData = {
    body?: never;
    path: {
        /**
         * id of key to get
         */
        id: number;
    };
    query?: never;
    url: '/user/gpg_keys/{id}';
};

export type UserCurrentGetGpgKeyErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentGetGpgKeyResponses = {
    /**
     * GPGKey
     */
    200: GpgKey;
};

export type UserCurrentGetGpgKeyResponse = UserCurrentGetGpgKeyResponses[keyof UserCurrentGetGpgKeyResponses];

export type UserListHooksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/hooks';
};

export type UserListHooksResponses = {
    /**
     * HookList
     */
    200: Array<Hook>;
};

export type UserListHooksResponse = UserListHooksResponses[keyof UserListHooksResponses];

export type UserCreateHookData = {
    body: CreateHookOption;
    path?: never;
    query?: never;
    url: '/user/hooks';
};

export type UserCreateHookResponses = {
    /**
     * Hook
     */
    201: Hook;
};

export type UserCreateHookResponse = UserCreateHookResponses[keyof UserCreateHookResponses];

export type UserDeleteHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to delete
         */
        id: number;
    };
    query?: never;
    url: '/user/hooks/{id}';
};

export type UserDeleteHookResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserGetHookData = {
    body?: never;
    path: {
        /**
         * id of the hook to get
         */
        id: number;
    };
    query?: never;
    url: '/user/hooks/{id}';
};

export type UserGetHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type UserGetHookResponse = UserGetHookResponses[keyof UserGetHookResponses];

export type UserEditHookData = {
    body?: EditHookOption;
    path: {
        /**
         * id of the hook to update
         */
        id: number;
    };
    query?: never;
    url: '/user/hooks/{id}';
};

export type UserEditHookResponses = {
    /**
     * Hook
     */
    200: Hook;
};

export type UserEditHookResponse = UserEditHookResponses[keyof UserEditHookResponses];

export type UserCurrentListKeysData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * fingerprint of the key
         */
        fingerprint?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/keys';
};

export type UserCurrentListKeysResponses = {
    /**
     * PublicKeyList
     */
    200: Array<PublicKey>;
};

export type UserCurrentListKeysResponse = UserCurrentListKeysResponses[keyof UserCurrentListKeysResponses];

export type UserCurrentPostKeyData = {
    body?: CreateKeyOption;
    path?: never;
    query?: never;
    url: '/user/keys';
};

export type UserCurrentPostKeyErrors = {
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type UserCurrentPostKeyResponses = {
    /**
     * PublicKey
     */
    201: PublicKey;
};

export type UserCurrentPostKeyResponse = UserCurrentPostKeyResponses[keyof UserCurrentPostKeyResponses];

export type UserCurrentDeleteKeyData = {
    body?: never;
    path: {
        /**
         * id of key to delete
         */
        id: number;
    };
    query?: never;
    url: '/user/keys/{id}';
};

export type UserCurrentDeleteKeyErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentDeleteKeyResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentGetKeyData = {
    body?: never;
    path: {
        /**
         * id of key to get
         */
        id: number;
    };
    query?: never;
    url: '/user/keys/{id}';
};

export type UserCurrentGetKeyErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentGetKeyResponses = {
    /**
     * PublicKey
     */
    200: PublicKey;
};

export type UserCurrentGetKeyResponse = UserCurrentGetKeyResponses[keyof UserCurrentGetKeyResponses];

export type OrgListCurrentUserOrgsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/orgs';
};

export type OrgListCurrentUserOrgsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListCurrentUserOrgsResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type OrgListCurrentUserOrgsResponse = OrgListCurrentUserOrgsResponses[keyof OrgListCurrentUserOrgsResponses];

export type UserCurrentListReposData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/repos';
};

export type UserCurrentListReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserCurrentListReposResponse = UserCurrentListReposResponses[keyof UserCurrentListReposResponses];

export type CreateCurrentUserRepoData = {
    body?: CreateRepoOption;
    path?: never;
    query?: never;
    url: '/user/repos';
};

export type CreateCurrentUserRepoErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * The repository with the same name already exists.
     */
    409: unknown;
    /**
     * APIValidationError is error format response related to input validation
     */
    422: unknown;
};

export type CreateCurrentUserRepoResponses = {
    /**
     * Repository
     */
    201: Repository;
};

export type CreateCurrentUserRepoResponse = CreateCurrentUserRepoResponses[keyof CreateCurrentUserRepoResponses];

export type GetUserSettingsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type GetUserSettingsResponses = {
    /**
     * UserSettings
     */
    200: Array<UserSettings>;
};

export type GetUserSettingsResponse = GetUserSettingsResponses[keyof GetUserSettingsResponses];

export type UpdateUserSettingsData = {
    body?: UserSettingsOptions;
    path?: never;
    query?: never;
    url: '/user/settings';
};

export type UpdateUserSettingsResponses = {
    /**
     * UserSettings
     */
    200: Array<UserSettings>;
};

export type UpdateUserSettingsResponse = UpdateUserSettingsResponses[keyof UpdateUserSettingsResponses];

export type UserCurrentListStarredData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/starred';
};

export type UserCurrentListStarredErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type UserCurrentListStarredResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserCurrentListStarredResponse = UserCurrentListStarredResponses[keyof UserCurrentListStarredResponses];

export type UserCurrentDeleteStarData = {
    body?: never;
    path: {
        /**
         * owner of the repo to unstar
         */
        owner: string;
        /**
         * name of the repo to unstar
         */
        repo: string;
    };
    query?: never;
    url: '/user/starred/{owner}/{repo}';
};

export type UserCurrentDeleteStarErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentDeleteStarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentCheckStarringData = {
    body?: never;
    path: {
        /**
         * owner of the repo
         */
        owner: string;
        /**
         * name of the repo
         */
        repo: string;
    };
    query?: never;
    url: '/user/starred/{owner}/{repo}';
};

export type UserCurrentCheckStarringErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentCheckStarringResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserCurrentPutStarData = {
    body?: never;
    path: {
        /**
         * owner of the repo to star
         */
        owner: string;
        /**
         * name of the repo to star
         */
        repo: string;
    };
    query?: never;
    url: '/user/starred/{owner}/{repo}';
};

export type UserCurrentPutStarErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCurrentPutStarResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserGetStopWatchesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/stopwatches';
};

export type UserGetStopWatchesResponses = {
    /**
     * StopWatchList
     */
    200: Array<StopWatch>;
};

export type UserGetStopWatchesResponse = UserGetStopWatchesResponses[keyof UserGetStopWatchesResponses];

export type UserCurrentListSubscriptionsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/subscriptions';
};

export type UserCurrentListSubscriptionsResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserCurrentListSubscriptionsResponse = UserCurrentListSubscriptionsResponses[keyof UserCurrentListSubscriptionsResponses];

export type UserListTeamsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/user/teams';
};

export type UserListTeamsResponses = {
    /**
     * TeamList
     */
    200: Array<Team>;
};

export type UserListTeamsResponse = UserListTeamsResponses[keyof UserListTeamsResponses];

export type UserCurrentTrackedTimesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
        /**
         * Only show times updated after the given time. This is a timestamp in RFC 3339 format
         */
        since?: string;
        /**
         * Only show times updated before the given time. This is a timestamp in RFC 3339 format
         */
        before?: string;
    };
    url: '/user/times';
};

export type UserCurrentTrackedTimesResponses = {
    /**
     * TrackedTimeList
     */
    200: Array<TrackedTime>;
};

export type UserCurrentTrackedTimesResponse = UserCurrentTrackedTimesResponses[keyof UserCurrentTrackedTimesResponses];

export type UserSearchData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * keyword
         */
        q?: string;
        /**
         * ID of the user to search for
         */
        uid?: number;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/search';
};

export type UserSearchResponses = {
    /**
     * SearchResults of a successful search
     */
    200: {
        data?: Array<User>;
        ok?: boolean;
    };
};

export type UserSearchResponse = UserSearchResponses[keyof UserSearchResponses];

export type UserGetData = {
    body?: never;
    path: {
        /**
         * username of user to get
         */
        username: string;
    };
    query?: never;
    url: '/users/{username}';
};

export type UserGetErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserGetResponses = {
    /**
     * User
     */
    200: User;
};

export type UserGetResponse = UserGetResponses[keyof UserGetResponses];

export type UserListActivityFeedsData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * if true, only show actions performed by the requested user
         */
        'only-performed-by'?: boolean;
        /**
         * the date of the activities to be found
         */
        date?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/activities/feeds';
};

export type UserListActivityFeedsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListActivityFeedsResponses = {
    /**
     * ActivityFeedsList
     */
    200: Array<Activity>;
};

export type UserListActivityFeedsResponse = UserListActivityFeedsResponses[keyof UserListActivityFeedsResponses];

export type UserListFollowersData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/followers';
};

export type UserListFollowersErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListFollowersResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserListFollowersResponse = UserListFollowersResponses[keyof UserListFollowersResponses];

export type UserListFollowingData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/following';
};

export type UserListFollowingErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListFollowingResponses = {
    /**
     * UserList
     */
    200: Array<User>;
};

export type UserListFollowingResponse = UserListFollowingResponses[keyof UserListFollowingResponses];

export type UserCheckFollowingData = {
    body?: never;
    path: {
        /**
         * username of following user
         */
        username: string;
        /**
         * username of followed user
         */
        target: string;
    };
    query?: never;
    url: '/users/{username}/following/{target}';
};

export type UserCheckFollowingErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserCheckFollowingResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type UserListGpgKeysData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/gpg_keys';
};

export type UserListGpgKeysErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListGpgKeysResponses = {
    /**
     * GPGKeyList
     */
    200: Array<GpgKey>;
};

export type UserListGpgKeysResponse = UserListGpgKeysResponses[keyof UserListGpgKeysResponses];

export type UserGetHeatmapDataData = {
    body?: never;
    path: {
        /**
         * username of user to get
         */
        username: string;
    };
    query?: never;
    url: '/users/{username}/heatmap';
};

export type UserGetHeatmapDataErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserGetHeatmapDataResponses = {
    /**
     * UserHeatmapData
     */
    200: Array<UserHeatmapData>;
};

export type UserGetHeatmapDataResponse = UserGetHeatmapDataResponses[keyof UserGetHeatmapDataResponses];

export type UserListKeysData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * fingerprint of the key
         */
        fingerprint?: string;
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/keys';
};

export type UserListKeysErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListKeysResponses = {
    /**
     * PublicKeyList
     */
    200: Array<PublicKey>;
};

export type UserListKeysResponse = UserListKeysResponses[keyof UserListKeysResponses];

export type OrgListUserOrgsData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/orgs';
};

export type OrgListUserOrgsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgListUserOrgsResponses = {
    /**
     * OrganizationList
     */
    200: Array<Organization>;
};

export type OrgListUserOrgsResponse = OrgListUserOrgsResponses[keyof OrgListUserOrgsResponses];

export type OrgGetUserPermissionsData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
        /**
         * name of the organization
         */
        org: string;
    };
    query?: never;
    url: '/users/{username}/orgs/{org}/permissions';
};

export type OrgGetUserPermissionsErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type OrgGetUserPermissionsResponses = {
    /**
     * OrganizationPermissions
     */
    200: OrganizationPermissions;
};

export type OrgGetUserPermissionsResponse = OrgGetUserPermissionsResponses[keyof OrgGetUserPermissionsResponses];

export type UserListReposData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/repos';
};

export type UserListReposErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListReposResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserListReposResponse = UserListReposResponses[keyof UserListReposResponses];

export type UserListStarredData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/starred';
};

export type UserListStarredErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListStarredResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserListStarredResponse = UserListStarredResponses[keyof UserListStarredResponses];

export type UserListSubscriptionsData = {
    body?: never;
    path: {
        /**
         * username of the user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/subscriptions';
};

export type UserListSubscriptionsErrors = {
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
};

export type UserListSubscriptionsResponses = {
    /**
     * RepositoryList
     */
    200: Array<Repository>;
};

export type UserListSubscriptionsResponse = UserListSubscriptionsResponses[keyof UserListSubscriptionsResponses];

export type UserGetTokensData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: {
        /**
         * page number of results to return (1-based)
         */
        page?: number;
        /**
         * page size of results
         */
        limit?: number;
    };
    url: '/users/{username}/tokens';
};

export type UserGetTokensErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type UserGetTokensResponses = {
    /**
     * AccessTokenList represents a list of API access token.
     */
    200: Array<AccessToken>;
};

export type UserGetTokensResponse = UserGetTokensResponses[keyof UserGetTokensResponses];

export type UserCreateTokenData = {
    body?: CreateAccessTokenOption;
    path: {
        /**
         * username of user
         */
        username: string;
    };
    query?: never;
    url: '/users/{username}/tokens';
};

export type UserCreateTokenErrors = {
    /**
     * APIError is error format response
     */
    400: unknown;
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
};

export type UserCreateTokenResponses = {
    /**
     * AccessToken represents an API access token.
     */
    201: AccessToken;
};

export type UserCreateTokenResponse = UserCreateTokenResponses[keyof UserCreateTokenResponses];

export type UserDeleteAccessTokenData = {
    body?: never;
    path: {
        /**
         * username of user
         */
        username: string;
        /**
         * token to be deleted, identified by ID and if not available by name
         */
        token: string;
    };
    query?: never;
    url: '/users/{username}/tokens/{token}';
};

export type UserDeleteAccessTokenErrors = {
    /**
     * APIForbiddenError is a forbidden error response
     */
    403: unknown;
    /**
     * APINotFound is a not found empty response
     */
    404: unknown;
    /**
     * APIError is error format response
     */
    422: unknown;
};

export type UserDeleteAccessTokenResponses = {
    /**
     * APIEmpty is an empty response
     */
    204: unknown;
};

export type GetVersionData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/version';
};

export type GetVersionResponses = {
    /**
     * ServerVersion
     */
    200: ServerVersion;
};

export type GetVersionResponse = GetVersionResponses[keyof GetVersionResponses];

export type ClientOptions = {
    baseUrl: `https://${string}/api/v1` | `http://${string}/api/v1` | (string & {});
};